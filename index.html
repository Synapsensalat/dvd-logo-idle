<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DVD Video IDLE</title>
    <style>
        /* Import Futura font if needed (example using Google Fonts - replace if hosted elsewhere) */
        /* @import url('https://fonts.googleapis.com/css2?family=Futura:wght@500&display=swap'); */
        /* Note: Futura isn't freely available on Google Fonts. Use a suitable alternative or ensure it's licensed/hosted. */
        /* Using common fallbacks for now. */

        :root {
            --tv-bg: #282828;
            --screen-bg: #111;
            --text-color: #eee;
            --border-color: #444;
            --highlight-color-hits: #0df; /* Teal */
            --highlight-color-corners: #0f0;
            --highlight-color-wall: #0df;
            --meta-color: #f0f; /* Pink */
            --collision-color: #f90;
            --tv-hover-light: #f50;
            --tv-upgrade-light: var(--highlight-color-hits);
            --modal-bg-translucent: rgba(25, 25, 25, 0.92);
            --modal-border: #555;
            --button-bg: #4a4a4a;
            --button-hover: #666;
            --button-active: #777;
            --disabled-color: #777;
            --accent-color: #eee;
            --main-bg-color: #000;
        }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--main-bg-color);
            font-family: 'Courier New', Courier, monospace; color: var(--text-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
        }

        /* --- Loading Screen Styles --- */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--main-bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
            opacity: 1;
        }

        /* Container for the masked logo */
        #loading-screen .loading-logo-container {
            width: 50%;
            max-width: 350px;
            aspect-ratio: 960 / 500; /* Match the source image aspect ratio */
            margin-bottom: 20px;
            /* Set the desired background color (Teal) */
            background-color: var(--highlight-color-hits);
            /* Apply the mask */
            mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            -webkit-mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
            mask-position: center;
            -webkit-mask-position: center;
        }
         /* Hide the actual img tag content within the container */
        #loading-screen .loading-logo-container img {
            opacity: 0; /* Hide the original image content */
            width: 100%; /* Make it fill the container for sizing */
            height: 100%;
            display: block;
        }

        #loading-screen .loading-text {
             /* START CHANGE: Font Change */
            font-family: 'Futura Medium', Futura, 'Century Gothic', AppleGothic, sans-serif; /* Use Futura Medium with fallbacks */
             /* END CHANGE */
            font-size: clamp(3rem, 10vw, 5rem);
            color: var(--meta-color); /* Pink */
            font-weight: 500; /* Futura Medium weight is typically 500 */
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 0;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .hidden { /* Utility class */
            display: none !important;
        }
        /* --- End Loading Screen Styles --- */


        #game-container {
            display: flex; flex-direction: column; align-items: center;
            justify-content: flex-start;
            width: 100%; height: 100%; padding: 10px; box-sizing: border-box; position: relative;
        }

        #top-info-bar {
            position: absolute; top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: center; align-items: center;
            gap: 20px;
            z-index: 10; pointer-events: none;
            flex-wrap: wrap;
        }
        .top-info-display {
            font-size: clamp(1.1rem, 2.5vw, 1.6rem); font-weight: bold;
            background-color: rgba(10, 10, 10, 0.6); padding: 3px 10px;
            border-radius: 5px; flex-shrink: 0; text-align: center;
        }
        #total-hits-display {
            color: var(--highlight-color-hits);
            text-shadow: 0 0 5px var(--highlight-color-hits);
        }
        #total-corner-hits-display {
            color: var(--highlight-color-corners);
            text-shadow: 0 0 5px var(--highlight-color-corners);
        }

        #tvs-display-area {
            display: flex; flex-wrap: wrap; justify-content: center;
            align-items: flex-start;
            gap: 15px;
            width: 100%; max-width: 1400px;
            padding: 15px; box-sizing: border-box;
            margin-top: 65px;
            max-height: calc(100vh - 90px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tv-instance-container {
            display: flex; flex-direction: column; align-items: center;
            width: clamp(300px, 35vw, 420px);
            flex-shrink: 0; position: relative;
        }

        .tv-frame {
            background-image: url('https://00s.myretrotvs.com/img/tvbackclean.webp');
            background-size: 100% calc(100% / 0.84);
            background-position: center top;
            background-repeat: no-repeat;
            position: relative;
            width: 100%;
            aspect-ratio: 1.25 / 0.84;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s ease;
            overflow: hidden;
        }

        .tv-screen {
            position: absolute;
            top: 9.4%;
            height: 74.1%;
            left: 12%;
            width: 76%;
            background-color: var(--screen-bg);
            overflow: hidden;
            border-radius: 5px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
            filter: url(#crt-effect);
        }

        .tv-screen::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.20) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.04), rgba(0, 255, 0, 0.015), rgba(0, 0, 255, 0.04)); background-size: 100% 2px, 3px 100%; z-index: 2; pointer-events: none; animation: crt-scanline 100s linear infinite; }
        @keyframes crt-scanline { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

        .box { position: absolute; background-color: #ffffff; /* Color set dynamically */ mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png'); -webkit-mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png'); mask-size: contain; -webkit-mask-size: contain; mask-repeat: no-repeat; -webkit-mask-repeat: no-repeat; mask-position: center; -webkit-mask-position: center; z-index: 1; filter: brightness(1.05); will-change: transform; }

        .spark-particle { position: absolute; width: 2px; height: 2px; border-radius: 50%; pointer-events: none; z-index: 10; opacity: 1; background-color: #fff; transition: transform 0.6s cubic-bezier(0.1, 0.7, 0.9, 1), opacity 0.6s ease-out; box-shadow: 0 0 3px #fff; }

        .tv-power-light {
            position: absolute;
            bottom: 2%;
            left: 53%;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #330800;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.5);
            opacity: 0;
            transition: background-color 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            z-index: 5;
        }

        .tv-frame:hover .tv-power-light {
            opacity: 1;
            background-color: var(--tv-hover-light);
            box-shadow: 0 0 5px 2px var(--tv-hover-light),
                        0 0 8px 3px rgba(255, 80, 0, 0.5),
                        inset 0 0 2px rgba(255, 255, 255, 0.3);
        }

        .tv-frame.can-upgrade-glow .tv-power-light {
            opacity: 1;
            background-color: var(--tv-upgrade-light);
            box-shadow: 0 0 6px 3px var(--tv-upgrade-light),
                        0 0 10px 4px rgba(0, 221, 255, 0.6),
                        inset 0 0 2px rgba(255, 255, 255, 0.4);
        }

        #upgrade-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; z-index: 1000; }
        #upgrade-modal.show { display: flex; }
        .modal-content { background-color: var(--modal-bg-translucent); padding: 20px 25px; border-radius: 10px; border: 1px solid var(--modal-border); box-shadow: 0 5px 25px rgba(0,0,0,0.5); width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; position: relative; }
        .modal-header { font-size: clamp(1.2rem, 3vw, 1.6rem); font-weight: bold; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); text-align: center; color: var(--accent-color); }
        .modal-header .tv-stats { font-size: 0.7em; font-weight: normal; color: #bbb; display: block; margin-top: 5px; }
        .modal-close-button { position: absolute; top: 10px; right: 15px; font-size: 1.8rem; color: var(--disabled-color); background: none; border: none; cursor: pointer; padding: 0; line-height: 1; }
        .modal-close-button:hover { color: var(--text-color); }
        #modal-buy-amount-container { display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; }
        .buy-amount-button { background-color: var(--button-bg); color: var(--accent-color); border: 1px solid var(--border-color); padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: background-color 0.2s; }
        .buy-amount-button:hover { background-color: var(--button-hover); }
        .buy-amount-button.active { background-color: var(--button-active); border-color: #999; font-weight: bold; }
        .upgrades-section { display: grid; grid-template-columns: repeat(auto-fit, minmax(125px, 1fr)); gap: 10px; width: 100%; margin-bottom: 15px;}
        .upgrade-button { background-color: var(--button-bg); color: var(--accent-color); border: 1px solid var(--border-color); padding: 10px 6px; border-radius: 6px; cursor: pointer; font-size: clamp(0.7rem, 2vw, 0.85rem); transition: background-color 0.2s, transform 0.1s; text-align: center; min-height: 65px; display: flex; flex-direction: column; justify-content: space-between; align-items: center; }
        .upgrade-button:hover:not(:disabled) { background-color: var(--button-hover); }
        .upgrade-button:active:not(:disabled) { transform: scale(0.96); }
        .upgrade-button:disabled { background-color: #333; color: var(--disabled-color); cursor: not-allowed; opacity: 0.6; }
        .upgrade-description { flex-grow: 1; margin-bottom: 4px; }
        .upgrade-cost { font-size: 0.9em; font-weight: bold; margin-top: auto; }
        .upgrade-cost.hit { color: var(--highlight-color-hits); }
        .upgrade-cost.meta { color: var(--meta-color); }
        #modal-reboot-section-container { width: 100%; }
        #reboot-section { border-top: 1px dashed var(--meta-color); margin-top: 15px; padding-top: 15px; text-align: center; }
        #reboot-info { margin-bottom: 8px; font-size: 0.85em; color: #ccc; }
        #reboot-gain-preview { margin-bottom: 12px; font-weight: bold; font-size: 0.9em; }
        #reboot-button { background-color: var(--meta-color); color: #fff; border: 1px solid #505; padding: 8px 18px; border-radius: 5px; cursor: pointer; font-size: 0.9rem; font-weight: bold; transition: background-color 0.2s, transform 0.1s; }
        #reboot-button:hover:not(:disabled) { background-color: #ff40ff; }
        #reboot-button:active:not(:disabled) { transform: scale(0.96); }
        #reboot-button:disabled { background-color: #606; color: var(--disabled-color); cursor: not-allowed; }
        #meta-menu-button { position: fixed; bottom: 15px; right: 15px; background-color: var(--meta-color); color: white; border: 1px solid #505; border-radius: 50%; width: 45px; height: 45px; font-size: 1.5rem; cursor: pointer; z-index: 900; display: none; justify-content: center; align-items: center; box-shadow: 0 3px 8px rgba(0,0,0,0.4); transition: background-color 0.2s, transform 0.2s; display: none; }
        #meta-menu-button:hover { background-color: #ff40ff; transform: scale(1.1); }
        #meta-menu-button.show { display: flex; }
        #notification { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); background-color: rgba(30, 30, 30, 0.85); color: white; padding: 8px 15px; border-radius: 5px; font-size: 0.85rem; opacity: 0; transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out; pointer-events: none; z-index: 1100; text-align: center; border: 1px solid #555;}
        #notification.show { opacity: 1; top: 25px; }

        .float-text { position: absolute; font-family: 'Courier New', Courier, monospace; font-weight: bold; z-index: 100; pointer-events: none; opacity: 0; white-space: pre; text-align: center; will-change: transform, opacity; }
        .corner-hit-text { top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--highlight-color-corners); font-size: clamp(1.5rem, 4vw, 2.4rem); text-shadow: 1px 1px #111, 0 0 15px var(--highlight-color-corners), 0 0 5px white; animation: cornerHitAnim 1.3s ease-out forwards; z-index: 101; }
        .collision-text { color: var(--collision-color); font-size: clamp(0.9rem, 2.5vw, 1.4rem); text-shadow: 1px 1px #111, 0 0 8px var(--collision-color); animation: floatFadeUp 0.9s ease-out forwards; z-index: 99; }
        .wall-hit-text { color: var(--highlight-color-wall); font-size: clamp(0.8rem, 2.2vw, 1.2rem); text-shadow: 1px 1px #111, 0 0 6px var(--highlight-color-wall); animation: floatFadeUp 0.8s ease-out forwards; z-index: 98; }

        @keyframes floatFadeUp { 0% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -150%) scale(0.8); } }
        @keyframes cornerHitAnim { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(0.95); } 100% { opacity: 0; transform: translate(-50%, -180%) scale(0.7); } }

        svg { position:absolute; height: 0; width: 0; }
    </style>
</head>
<body>

<!-- Loading Screen HTML -->
<div id="loading-screen">
    <div class="loading-logo-container">
         <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png" alt="">
    </div>
    <p class="loading-text">IDLE</p>
</div>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <defs>
    <filter id="crt-effect">
      <feGaussianBlur stdDeviation="0.2" result="blurred"/>
      <feComponentTransfer in="blurred" result="contrastBoost">
         <feFuncR type="linear" slope="1.03" intercept="-0.005"/>
         <feFuncG type="linear" slope="1.03" intercept="-0.005"/>
         <feFuncB type="linear" slope="1.03" intercept="-0.005"/>
      </feComponentTransfer>
    </filter>
  </defs>
</svg>

<div id="game-container">
    <div id="top-info-bar">
        <div id="total-hits-display" class="top-info-display">Hits: 0</div>
        <div id="total-corner-hits-display" class="top-info-display">Corners: 0</div>
    </div>
    <div id="tvs-display-area"></div>
    <button id="meta-menu-button" aria-label="Meta Upgrades & Reboot">✵</button>
</div>

<div id="upgrade-modal">
    <div class="modal-content">
        <button class="modal-close-button" aria-label="Close Modal">×</button>
        <div class="modal-header">
            <span id="modal-title">Upgrades</span>
            <span id="modal-tv-stats" class="tv-stats"></span>
        </div>
        <div id="modal-buy-amount-container"></div>
        <div id="modal-upgrades-section" class="upgrades-section"></div>
        <div id="modal-reboot-section-container"></div>
    </div>
</div>

<div id="reboot-section-template" style="display: none;">
    <div id="reboot-section">
        <div id="reboot-info">Reboot to gain Fragments based on total Hits this session.</div>
        <div id="reboot-gain-preview">Gain ~0 Fragments</div>
        <button id="reboot-button" disabled>Reboot System</button>
    </div>
</div>

<div id="notification"></div>

<script>
    (function() {

        // --- Game Constants ---
        const DEV_SPEED_FACTOR = 1;
        const DVD_LOGO_URL = 'https://upload.wikimedia.org/wikipedia/commons/6/64/DVD_VIDEO_logo.png';
        const TV_BACKGROUND_URL = 'https://00s.myretrotvs.com/img/tvbackclean.webp';
        const BASE_LOGO_HEIGHT_SCREEN_RATIO = 0.14;
        const BASE_BOX_ASPECT_RATIO = 1.6;
        const BASE_SPEED_CONSTANT = 1.0;
        const MAX_BOXES_PER_TV = 15;
        const SAVE_VERSION = 'v0.1'; // Keeping version unless structure changes
        const SAVE_KEY = `idleDVDMultiverseSave_${SAVE_VERSION}`;
        const TICK_RATE_MS = 16;
        const COLLISION_ENERGY_LOSS = 0.96;
        const BOX_COLLISION_COOLDOWN_MS = 100;
        const BOX_COLLISION_SEPARATION_BUFFER = 0.1;
        const TV_COST_SCALING_FACTOR = 1.8;
        const MAX_BULK_BUY_CHECK = 10000;
        const IDLE_HITS_PER_SEC_PER_BOX_BASE_FACTOR = 0.6;
        const MIN_LOADING_TIME_MS = 2000;

        // --- DOM Element Selection ---
        const loadingScreen = document.getElementById('loading-screen');
        const totalHitsDisplay = document.getElementById('total-hits-display');
        const totalCornerHitsDisplay = document.getElementById('total-corner-hits-display');
        const tvsDisplayArea = document.getElementById('tvs-display-area');
        const notificationElement = document.getElementById('notification');
        const upgradeModal = document.getElementById('upgrade-modal');
        const modalContent = upgradeModal.querySelector('.modal-content');
        const modalCloseButton = upgradeModal.querySelector('.modal-close-button');
        const modalTitle = upgradeModal.querySelector('#modal-title');
        const modalTvStats = upgradeModal.querySelector('#modal-tv-stats');
        const modalBuyAmountContainer = upgradeModal.querySelector('#modal-buy-amount-container');
        const modalUpgradesContainer = upgradeModal.querySelector('#modal-upgrades-section');
        const modalRebootContainer = upgradeModal.querySelector('#modal-reboot-section-container');
        const metaMenuButton = document.getElementById('meta-menu-button');

        // --- Game State ---
        let globalState;
        let selectedTvIndex = -1;
        let gameLoopInterval = null;
        let lastTimestamp = 0;
        let lastSaveTime = 0;
        let nextTvId = 0;
        let boxCollisionTimers = {};
        let selectedBuyAmount = 1;
        let timeHidden = null;

        // --- Utility Functions ---
        const calculateCost = (baseCost, level, factor = 1.5, tvIndex = -1) => { let cost = baseCost * Math.pow(factor, level); if (tvIndex >= 0 && tvIndex > 0) { cost *= Math.pow(TV_COST_SCALING_FACTOR, tvIndex); } return Math.max(1, Math.floor(cost)); };
        const formatScore = (value) => { const V = Math.floor(value); if (V < 1e4) return V.toLocaleString(); if (V < 1e6) return (V / 1e3).toFixed(V < 100e3 ? 1 : 0) + 'K'; if (V < 1e9) return (V / 1e6).toFixed(V < 100e6 ? 1 : 0) + 'M'; if (V < 1e12) return (V / 1e9).toFixed(V < 100e9 ? 1 : 0) + 'B'; if (V < 1e15) return (V / 1e12).toFixed(V < 100e12 ? 1 : 0) + 'T'; if (V < 1e18) return (V / 1e15).toFixed(V < 100e15 ? 1 : 0) + 'Qd'; return (V / 1e18).toFixed(1) + 'Qn'; };
        function getRandomColor() { let r, g, b; let color = '#'; const letters = '0123456789ABCDEF'; do { color = '#'; for (let i = 0; i < 6; i++) { color += letters[Math.floor(Math.random() * 16)]; } r = parseInt(color.substring(1, 3), 16); g = parseInt(color.substring(3, 5), 16); b = parseInt(color.substring(5, 7), 16); } while (r + g + b < 450 || (r > 200 && g > 200 && b > 200)); return color; }
        function getBoxCollisionKey(id1, id2) { return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`; }

        // --- Image Preloading ---
        function preloadImages(urls) {
            const promises = urls.map(url => {
                return new Promise((resolve) => { // Always resolve
                    const img = new Image();
                    img.onload = resolve;
                    img.onerror = (err) => {
                        console.error(`Failed to load image: ${url}`, err);
                        resolve(); // Resolve even on error
                    };
                    img.src = url;
                });
            });
            return Promise.all(promises);
        }

        // --- TV & Box Creation / Management ---
        function createTvDom(tvState) {
            const container = document.createElement('div');
            container.classList.add('tv-instance-container');
            container.dataset.tvIndex = tvState.index;

            const tvFrame = document.createElement('div');
            tvFrame.classList.add('tv-frame');
            tvFrame.id = `tv-frame-${tvState.id}`;
            tvFrame.onclick = (e) => { e.stopPropagation(); openUpgradeModal(tvState.index); };

            const tvScreen = document.createElement('div');
            tvScreen.classList.add('tv-screen');
            tvScreen.id = `tv-screen-${tvState.id}`;
            tvFrame.appendChild(tvScreen);

            const powerLight = document.createElement('div');
            powerLight.classList.add('tv-power-light');
            tvFrame.appendChild(powerLight);

            container.appendChild(tvFrame);
            tvsDisplayArea.appendChild(container);

            tvState.elements = {
                container,
                frame: tvFrame,
                screen: tvScreen,
                powerLight: powerLight
            };
            resizeTvScreen(tvState);
            updateTvGlow(tvState.index);
        }

        function createBoxElement(tvState, boxData) {
            if (!tvState.elements || !tvState.elements.screen) {
                console.error("TV screen element not found when creating box for TV", tvState.id);
                return null;
            }
            if (!tvState.screenWidth || !tvState.screenHeight) {
                 console.warn("Screen dimensions not ready for TV", tvState.id, "retrying box creation soon.");
                 setTimeout(() => {
                    if(tvState.boxes.find(b => b.id === boxData.id && !b.element)) {
                        const reBox = tvState.boxes.find(b => b.id === boxData.id);
                        if (reBox) {
                            reBox.element = createBoxElement(tvState, reBox);
                            if(reBox.element) {
                                reBox.element.style.transform = `translate(${reBox.x}px, ${reBox.y}px)`;
                            }
                        }
                    }
                 }, 100);
                 return null;
             }

            const boxElement = document.createElement('div');
            boxElement.classList.add('box');
            boxElement.id = `tv${tvState.id}-box${boxData.id}`;
            boxElement.style.width = `${tvState.dynamicBoxWidth}px`;
            boxElement.style.height = `${tvState.dynamicBoxHeight}px`;
            boxElement.style.transform = `translate(${boxData.x}px, ${boxData.y}px)`;
            boxElement.style.backgroundColor = getRandomColor(); // Set dynamic color here
            boxElement.style.maskImage = `url('${DVD_LOGO_URL}')`;
            boxElement.style.webkitMaskImage = `url('${DVD_LOGO_URL}')`;
            tvState.elements.screen.appendChild(boxElement);
            return boxElement;
        }

        function addBoxToTv(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
            const currentMaxBoxes = globalState.maxBoxesPerTv;
            if (!tvState || tvState.boxes.length >= currentMaxBoxes) return false;

            if (!tvState.elements || !tvState.elements.screen || !tvState.screenWidth || !tvState.screenHeight) {
                 console.warn(`TV ${tvState.id}: Screen dimensions not ready, delaying box add.`);
                 resizeTvScreen(tvState);
                 setTimeout(() => addBoxToTv(tvIndex), 100);
                 return false;
             }

            const id = tvState.nextBoxId++;
            const speed = getCurrentTvSpeed(tvState);
            const baseAngle = Math.PI / 4;
            const randomOffset = (Math.random() - 0.5) * (Math.PI / 6);
            const randomQuadrant = Math.floor(Math.random() * 4);
            const angle = baseAngle + randomOffset + randomQuadrant * (Math.PI / 2);

            let startX, startY, attempts = 0, tooClose;
            do {
                startX = Math.random() * (tvState.screenWidth - tvState.dynamicBoxWidth);
                startY = Math.random() * (tvState.screenHeight - tvState.dynamicBoxHeight);
                tooClose = tvState.boxes.some(eB => {
                    const dx=startX-eB.x; const dy=startY-eB.y;
                    return (dx*dx+dy*dy) < Math.pow(tvState.dynamicBoxWidth*1.5, 2);
                });
                attempts++;
            } while (tooClose && attempts < 10);

            const newBox = {
                id: id,
                x: startX,
                y: startY,
                vx: Math.cos(angle) * speed * 0.7,
                vy: Math.sin(angle) * speed * 0.7,
                element: null
            };

            newBox.element = createBoxElement(tvState, newBox);

            if (newBox.element || !tvState.screenWidth) {
                 tvState.boxes.push(newBox);
                 updateTvGlow(tvIndex);
                 return true;
            } else {
                 console.error("Failed to create box element immediately for TV", tvState.id);
                 tvState.nextBoxId--;
                 return false;
            }
        }

        function addTv() {
            const newIndex = globalState.tvStates.length;
            const newId = nextTvId++;
            const newTvState = createDefaultTvState(newIndex, newId);
            applyMetaUpgradesToTv(newTvState);
            globalState.tvStates.push(newTvState);
            createTvDom(newTvState);
            addBoxToTv(newIndex);
            recalculateGlobalSynergy();
            updateMetaUpgradeButtonsIfVisible();
            updateAllTvGlows();
            showNotification(`TV #${newId} Online`);
            return newTvState;
        }
        function removeAllDomElements() { tvsDisplayArea.innerHTML = ''; globalState.tvStates.forEach(tv => tv.elements = null); }
        function recreateAllDomElements() {
             removeAllDomElements();
             globalState.tvStates.forEach(tvState => {
                createTvDom(tvState);
                tvState.boxes.forEach(box => {
                    if (typeof box.x !== 'number' || typeof box.y !== 'number' || typeof box.vx !== 'number' || typeof box.vy !== 'number') {
                        console.warn(`Invalid box data on load for TV ${tvState.id} box ${box.id}. Removing.`);
                        tvState.boxes = tvState.boxes.filter(b => b.id !== box.id);
                        return;
                    }
                    box.element = createBoxElement(tvState, box);
                    if (!box.element) {
                        console.warn(`Box element recreation potentially delayed for TV ${tvState.id} box ${box.id}`);
                    }
                 });
                 resizeTvScreen(tvState);
                 checkAndAdjustBoxPositions(tvState.index);
                 updateTvGlow(tvState.index);
             });
             updateAllTvGlows();
        }
         function clearTvScreenBoxes(tvIndex) {
             const tvState = globalState.tvStates[tvIndex];
             if (tvState && tvState.elements && tvState.elements.screen) {
                 tvState.elements.screen.innerHTML = '';
             }
         }

        // --- Sizing and Positioning ---
        function resizeTvScreen(tvState) {
            if (!tvState.elements || !tvState.elements.screen) {
                 return;
            }
            const screenRect = tvState.elements.screen.getBoundingClientRect();

            if (screenRect.width <= 0 || screenRect.height <= 0) {
                if (!document.hidden) {
                    setTimeout(() => resizeTvScreen(tvState), 50);
                }
                return;
            }

            tvState.screenWidth = screenRect.width;
            tvState.screenHeight = screenRect.height;
            tvState.dynamicBoxHeight = Math.max(8, Math.floor(tvState.screenHeight * BASE_LOGO_HEIGHT_SCREEN_RATIO));
            tvState.dynamicBoxWidth = Math.floor(tvState.dynamicBoxHeight * BASE_BOX_ASPECT_RATIO);

            tvState.boxes.forEach(box => {
                if (box.element) {
                    box.element.style.width = `${tvState.dynamicBoxWidth}px`;
                    box.element.style.height = `${tvState.dynamicBoxHeight}px`;
                }
            });
        }

        function handleGlobalResize() {
            globalState.tvStates.forEach(tvState => {
                resizeTvScreen(tvState);
                checkAndAdjustBoxPositions(tvState.index);
            });
        }
        function checkAndAdjustBoxPositions(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
            if (!tvState || !tvState.screenWidth || !tvState.screenHeight || !tvState.dynamicBoxWidth) {
                 return;
             }
            tvState.boxes.forEach(box => {
                box.x = Math.max(0, Math.min(box.x ?? tvState.screenWidth/2, tvState.screenWidth - tvState.dynamicBoxWidth));
                box.y = Math.max(0, Math.min(box.y ?? tvState.screenHeight/2, tvState.screenHeight - tvState.dynamicBoxHeight));
                if (box.element) {
                    box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                }
            });
        }

        // --- Update Loop ---
        function gameLoop(timestamp) {
            if (document.hidden) { return; }
            if (!lastTimestamp) { lastTimestamp = timestamp; return; }
            const deltaTime = Math.min(0.1, (timestamp - lastTimestamp) / 1000);
            lastTimestamp = timestamp;

            globalState.tvStates.forEach((tvState, tvIndex) => {
                 if (!tvState.screenWidth || tvState.screenWidth <= 0) {
                    resizeTvScreen(tvState);
                 } else {
                    updateSingleTv(tvState, tvIndex, deltaTime, timestamp);
                 }
             });
            updateTotalHitsDisplay();
            updateTotalCornerHitsDisplay();
            updateAllTvGlows();
            updateRebootPreviewIfVisible();
            checkMetaButtonVisibility();

            const now = Date.now();
            if (now - lastSaveTime > 5000) {
                saveGame();
                lastSaveTime = now;
                if(upgradeModal.classList.contains('show')) {
                    if(selectedTvIndex !== -1) updateSelectedTvUpgradeButtons();
                    else updateMetaUpgradeButtonsIfVisible();
                }
            }
        }

        function updateSingleTv(tvState, tvIndex, deltaTime, timestamp) {
             if (!tvState.screenWidth || !tvState.screenHeight || !tvState.dynamicBoxWidth || !tvState.dynamicBoxHeight) {
                 resizeTvScreen(tvState);
                 return;
             }
            const screenWidth = tvState.screenWidth;
            const screenHeight = tvState.screenHeight;
            const effectiveBoxWidth = tvState.dynamicBoxWidth;
            const effectiveBoxHeight = tvState.dynamicBoxHeight;
            const currentSpeed = getCurrentTvSpeed(tvState);
            let cornerHitData = [];
            let boxCollisionsThisFrame = [];
            let wallHitData = [];

            tvState.boxes.forEach(box => {
                 if (!box.element) {
                     box.element = createBoxElement(tvState, box);
                     if(!box.element) return;
                  }

                if (isNaN(box.vx) || isNaN(box.vy)) return;
                let boxVX = box.vx; let boxVY = box.vy;
                const speedMagnitude = Math.sqrt(boxVX**2 + boxVY**2);
                if (speedMagnitude > 0.01 && Math.abs(speedMagnitude - currentSpeed) > 0.1 * currentSpeed) {
                    const sf = currentSpeed/speedMagnitude;
                    boxVX*=(isNaN(sf)?1:sf); boxVY*=(isNaN(sf)?1:sf);
                } else if (speedMagnitude < 0.1*currentSpeed && currentSpeed > 0.1) {
                    const a = Math.random()*Math.PI*2;
                    boxVX=Math.cos(a)*currentSpeed*0.5; boxVY=Math.sin(a)*currentSpeed*0.5;
                }
                let deltaX = boxVX*deltaTime*60;
                let deltaY = boxVY*deltaTime*60;
                deltaX = Math.max(-effectiveBoxWidth*0.8,Math.min(effectiveBoxWidth*0.8,deltaX));
                deltaY = Math.max(-effectiveBoxHeight*0.8,Math.min(effectiveBoxHeight*0.8,deltaY));
                box.x += deltaX;
                box.y += deltaY;

                let hitWall=false; let hitX=false, hitY=false; let hitSide = '';
                if (box.x <= 0 && boxVX < 0) { box.x = 0+Math.random()*0.1; boxVX = Math.abs(boxVX); hitWall=true; hitX=true; hitSide='left';}
                else if (box.x >= screenWidth-effectiveBoxWidth && boxVX > 0) { box.x = screenWidth-effectiveBoxWidth-Math.random()*0.1; boxVX = -Math.abs(boxVX); hitWall=true; hitX=true; hitSide='right';}
                if (box.y <= 0 && boxVY < 0) { box.y = 0+Math.random()*0.1; boxVY = Math.abs(boxVY); hitWall=true; hitY=true; hitSide='top';}
                else if (box.y >= screenHeight-effectiveBoxHeight && boxVY > 0) { box.y = screenHeight-effectiveBoxHeight-Math.random()*0.1; boxVY = -Math.abs(boxVY); hitWall=true; hitY=true; hitSide='bottom';}

                if (hitWall) {
                    if (box.element) box.element.style.backgroundColor = getRandomColor();
                    const cornerThreshold = Math.min(1.5, effectiveBoxWidth * 0.03, effectiveBoxHeight * 0.03);
                    const isNearLeft = box.x <= cornerThreshold;
                    const isNearRight = box.x >= screenWidth-effectiveBoxWidth-cornerThreshold;
                    const isNearTop = box.y <= cornerThreshold;
                    const isNearBottom = box.y >= screenHeight-effectiveBoxHeight-cornerThreshold;
                    const isCorner = (isNearLeft || isNearRight) && (isNearTop || isNearBottom);

                    if (isCorner && hitX && hitY) {
                        globalState.totalCornerHits++;
                        let cornerX = isNearLeft ? 0 : screenWidth;
                        let cornerY = isNearTop ? 0 : screenHeight;
                        const escapeFactor = 1.08;
                        if (isNearLeft) boxVX=Math.abs(boxVX)*escapeFactor; else boxVX=-Math.abs(boxVX)*escapeFactor;
                        if (isNearTop) boxVY=Math.abs(boxVY)*escapeFactor; else boxVY=-Math.abs(boxVY)*escapeFactor;
                        const baseBonus = tvState.cornerHitBaseBonus;
                        const percentBonus = globalState.lifetimeSessionHits * tvState.cornerHitPercentBonus;
                        const totalCornerBonus = (baseBonus + percentBonus);
                        cornerHitData.push({ x: cornerX, y: cornerY, boxId: box.id, bonusAmount: totalCornerBonus });
                    }
                    else {
                        const wallHitAmount = tvState.hitValue;
                        addTvHitScore(wallHitAmount);
                        let popupX = box.x + effectiveBoxWidth / 2;
                        let popupY = box.y + effectiveBoxHeight / 2;
                        if (hitSide === 'left') popupX = effectiveBoxWidth * 0.5; else if (hitSide === 'right') popupX = screenWidth - effectiveBoxWidth * 0.5;
                        if (hitSide === 'top') popupY = effectiveBoxHeight * 0.5; else if (hitSide === 'bottom') popupY = screenHeight - effectiveBoxHeight * 0.5;
                        wallHitData.push({ x: popupX, y: popupY, amount: wallHitAmount });
                    }
                }
                box.vx = boxVX; box.vy = boxVY;
                box.x = Math.max(0, Math.min(box.x, screenWidth - effectiveBoxWidth));
                box.y = Math.max(0, Math.min(box.y, screenHeight - effectiveBoxHeight));
            });

            for (let i = 0; i < tvState.boxes.length; i++) {
                 if (!tvState.boxes[i].element) continue;
                 for (let j = i + 1; j < tvState.boxes.length; j++) {
                    if (!tvState.boxes[j].element) continue;

                    const b1 = tvState.boxes[i]; const b2 = tvState.boxes[j];
                    const b1CenterX = b1.x + effectiveBoxWidth / 2; const b1CenterY = b1.y + effectiveBoxHeight / 2;
                    const b2CenterX = b2.x + effectiveBoxWidth / 2; const b2CenterY = b2.y + effectiveBoxHeight / 2;
                    const dx = b2CenterX - b1CenterX; const dy = b2CenterY - b1CenterY;
                    const overlapX = (effectiveBoxWidth) - Math.abs(dx); const overlapY = (effectiveBoxHeight) - Math.abs(dy);

                    if (overlapX > 0 && overlapY > 0) {
                        const collisionKey = getBoxCollisionKey(b1.id, b2.id);
                        const lastCollisionTime = boxCollisionTimers[collisionKey] || 0;
                        if (timestamp - lastCollisionTime < BOX_COLLISION_COOLDOWN_MS) continue;
                        boxCollisionTimers[collisionKey] = timestamp;

                        if (overlapX < overlapY) {
                            const separationAmount = overlapX * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dx < 0 ? -1 : 1;
                            b1.x -= separationAmount * sign; b2.x += separationAmount * sign;
                            const v1x = b1.vx; const v2x = b2.vx;
                            b1.vx = v2x * COLLISION_ENERGY_LOSS; b2.vx = v1x * COLLISION_ENERGY_LOSS;
                            if ((sign > 0 && b1.vx >= b2.vx) || (sign < 0 && b1.vx <= b2.vx)) { b1.vx = -sign * Math.abs(v2x * 0.5); b2.vx = sign * Math.abs(v1x * 0.5); }
                        } else {
                            const separationAmount = overlapY * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dy < 0 ? -1 : 1;
                            b1.y -= separationAmount * sign; b2.y += separationAmount * sign;
                            const v1y = b1.vy; const v2y = b2.vy;
                            b1.vy = v2y * COLLISION_ENERGY_LOSS; b2.vy = v1y * COLLISION_ENERGY_LOSS;
                            if ((sign > 0 && b1.vy >= b2.vy) || (sign < 0 && b1.vy <= b2.vy)) { b1.vy = -sign * Math.abs(v2y * 0.5); b2.vy = sign * Math.abs(v1y * 0.5); }
                        }
                        b1.x = Math.max(0, Math.min(b1.x, screenWidth - effectiveBoxWidth)); b1.y = Math.max(0, Math.min(b1.y, screenHeight - effectiveBoxHeight));
                        b2.x = Math.max(0, Math.min(b2.x, screenWidth - effectiveBoxWidth)); b2.y = Math.max(0, Math.min(b2.y, screenHeight - effectiveBoxHeight));

                        boxCollisionsThisFrame.push({ b1Id: b1.id, b2Id: b2.id, x: b1CenterX + dx / 2, y: b1CenterY + dy / 2 });
                    }
                }
            }

            if (wallHitData.length > 0) { wallHitData.forEach(hit => { showFloatText(tvState, `+${formatScore(Math.ceil(hit.amount * DEV_SPEED_FACTOR * globalState.synergyBonus))}`, hit.x, hit.y, 'wall'); }); }
            if (cornerHitData.length > 0) { cornerHitData.forEach(hit => { addTvHitScore(hit.bonusAmount); createSparkParticles(tvState, hit.x, hit.y); showFloatText(tvState, `CORNER HIT!\n+${formatScore(Math.ceil(hit.bonusAmount * DEV_SPEED_FACTOR * globalState.synergyBonus))}`, tvState.screenWidth/2, tvState.screenHeight/2, 'corner'); }); }
            if (boxCollisionsThisFrame.length > 0) {
                let collisionValue = tvState.boxCollisionValue;
                let totalCollisionBonus = boxCollisionsThisFrame.length * collisionValue;
                addTvHitScore(totalCollisionBonus);
                boxCollisionsThisFrame.forEach(hit => {
                    showFloatText(tvState, `+${formatScore(Math.ceil(collisionValue * DEV_SPEED_FACTOR * globalState.synergyBonus))}`, hit.x, hit.y, 'collision');
                });
            }

            tvState.boxes.forEach(box => {
                if (box.element) {
                     box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                }
            });

            if (upgradeModal.classList.contains('show') && selectedTvIndex === tvIndex) {
                updateModalTvStats(tvState);
            }
        }

        // --- Scoring & Stats ---
        function addTvHitScore(amount) { if (amount <= 0 || isNaN(amount)) return; const amountWithSynergy = amount * globalState.synergyBonus; const effectiveGain = Math.ceil(amountWithSynergy * DEV_SPEED_FACTOR); if (effectiveGain <= 0) return; globalState.totalSessionHits += effectiveGain; globalState.lifetimeSessionHits += effectiveGain; }
        function updateModalTvStats(tvState) { if (!modalTvStats || !tvState) return; const currentMaxBoxes = globalState.maxBoxesPerTv; modalTvStats.textContent = `TV #${tvState.id} | Logos: ${tvState.boxes.length}/${currentMaxBoxes}`; }
        function updateTotalHitsDisplay() { if (totalHitsDisplay) { totalHitsDisplay.textContent = `Hits: ${formatScore(globalState.totalSessionHits)}`; } }
        function updateTotalCornerHitsDisplay() { if (totalCornerHitsDisplay) { totalCornerHitsDisplay.textContent = `Corners: ${formatScore(globalState.totalCornerHits)}`; } }

        // --- Effects & Feedback ---
        function createSparkParticles(tvState, cornerX, cornerY) { if (!tvState.elements || !tvState.elements.screen) return; const screenElement = tvState.elements.screen; const particleCount = 12; const particleLifespan = 650; const particleSpread = tvState.screenWidth * 0.18; for (let i = 0; i < particleCount; i++) { const p = document.createElement('div'); p.classList.add('spark-particle'); p.style.left = `${cornerX}px`; p.style.top = `${cornerY}px`; screenElement.appendChild(p); const ang = Math.random()*Math.PI*2; const dist = Math.random()*particleSpread; let dX=Math.cos(ang); let dY=Math.sin(ang); if(cornerX<tvState.screenWidth/2) dX=Math.abs(dX); else dX=-Math.abs(dX); if(cornerY<tvState.screenHeight/2) dY=Math.abs(dY); else dY=-Math.abs(dY); const tX=dX*dist; const tY=dY*dist; requestAnimationFrame(()=>{p.style.transform=`translate(${tX}px, ${tY}px) scale(0.5)`; p.style.opacity=0; }); setTimeout(()=>{ p.remove(); }, particleLifespan); } }
        function showNotification(message) { if (!notificationElement) return; notificationElement.textContent = message; notificationElement.className = 'show'; if (notificationElement.timer) clearTimeout(notificationElement.timer); notificationElement.timer = setTimeout(() => { notificationElement.className = ''; notificationElement.timer = null; }, 2200); }
        function showFloatText(tvState, text, x, y, type = 'corner' | 'collision' | 'wall') { if (!tvState.elements || !tvState.elements.screen) return; const screenElement = tvState.elements.screen; const textElement = document.createElement('div'); textElement.classList.add('float-text'); let textClass = ''; let duration = 1000; switch(type) { case 'corner': textClass = 'corner-hit-text'; duration = 1300; break; case 'collision': textClass = 'collision-text'; duration = 900; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break; case 'wall': textClass = 'wall-hit-text'; duration = 800; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break; default: return; } textElement.classList.add(textClass); textElement.textContent = text; screenElement.appendChild(textElement); setTimeout(() => { textElement.remove(); }, duration); }

        // --- Glow Logic (Controls Power Light) ---
        function checkTvAffordability(tvState) {
             if (!tvState) return false;
             const currentHits = globalState.totalSessionHits;
             for (const upgrade of tvUpgrades) {
                 const level = upgrade.getLevel(tvState);
                 let maxLevel;
                 if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv;
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(tvState);
                 else maxLevel = upgrade.maxLevel;
                 const isMaxLevel = (maxLevel !== undefined && level >= maxLevel);
                 if (isMaxLevel) continue;

                 let canPurchaseCheck = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, level) : true;
                 if (!canPurchaseCheck) continue;

                 const cost = calculateCost(upgrade.baseCost, level, upgrade.costFactor, tvState.index);
                 if (currentHits >= cost) {
                     return true;
                 }
             }
             return false;
        }
        function updateTvGlow(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
            if (tvState && tvState.elements && tvState.elements.frame) {
                const frame = tvState.elements.frame;
                const canAfford = checkTvAffordability(tvState);
                frame.classList.toggle('can-upgrade-glow', canAfford);
            }
        }
        function updateAllTvGlows() {
             globalState.tvStates.forEach((tv, index) => updateTvGlow(index));
        }

        // --- Upgrade Definitions ---
        const tvUpgrades = [
             { id: 'hitValue', name: 'Hit Value', baseCost: 10, costFactor: 1.45, getLevel: (tv) => tv.upgrades.hitValue, applyEffect: (tv) => { tv.upgrades.hitValue++; }, getDescription: (tv, l) => `Lv ${l}: +Hit Value` },
             { id: 'speed', name: 'Speed', baseCost: 40, costFactor: 1.65, maxLevel: 25, getLevel: (tv) => tv.upgrades.speed, applyEffect: (tv) => { tv.upgrades.speed++; }, getDescription: (tv, l, maxed) => maxed ? `Max Speed (Lv ${l})` : `Lv ${l}: +Speed` },
             { id: 'cornerBonusFlat', name: 'Corner Flat Bonus', baseCost: 60, costFactor: 1.75, getLevel: (tv) => tv.upgrades.cornerBonusFlat, applyEffect: (tv) => { tv.upgrades.cornerBonusFlat++; }, getDescription: (tv, l) => `Lv ${l}: +Corner Bonus` },
             { id: 'cornerBonusPercent', name: 'Corner % Bonus', baseCost: 800, costFactor: 2.3, getLevel: (tv) => tv.upgrades.cornerBonusPercent, applyEffect: (tv) => { tv.upgrades.cornerBonusPercent++; }, getDescription: (tv, l) => `Lv ${l}: +${(deriveTvCornerPercentBonus(tv,l+1)*100).toFixed(4)}% CB<br>(Global Hits)` },
             { id: 'multiBox', name: 'Add Logo', baseCost: 300, costFactor: 3.5,
                getMaxLevel: (tv) => globalState.maxBoxesPerTv, getLevel: (tv) => tv.boxes.length,
                applyEffect: (tv, tvIndex, count = 1) => { let added = 0; for (let i = 0; i < count; i++) { if(addBoxToTv(tvIndex)) added++; else break; } if (added < count && count > 1 && tv.boxes.length >= globalState.maxBoxesPerTv) showNotification("Max logos reached!"); return added > 0; },
                canPurchase: (tv, levelToCheck) => (levelToCheck ?? tv.boxes.length) < globalState.maxBoxesPerTv,
                getDescription: (tv, l, maxed) => maxed ? `Max Logos (${tv.boxes.length})` : `Add Logo (${l+1}/${globalState.maxBoxesPerTv})` },
             { id: 'boxCollisionValue', name: 'Collision Hits', baseCost: 1500, costFactor: 1.95, getLevel: (tv) => tv.upgrades.boxCollisionValue, applyEffect: (tv) => { tv.upgrades.boxCollisionValue++; }, getDescription: (tv, l) => `Lv ${l}: +Collision Hits` },
        ];
        const metaUpgrades = [
             { id: 'metaFragmentGain', name: 'Fragment Gain', baseCost: 3, costFactor: 2.2, getLevel: () => globalState.metaLevels.fragmentGain, applyEffect: () => { globalState.metaLevels.fragmentGain++; }, getDescription: (gs, l, c) => `Lv ${l}: +${((deriveMetaFragmentMult(l+1)-1)*100).toFixed(0)}% Fragments<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaAddTv', name: 'Add New TV', baseCost: 5, costFactor: 4.5, getLevel: () => globalState.tvStates.length, applyEffect: () => { addTv(); }, canPurchase: () => true, getDescription: (gs, l, c) => `Add TV #${l+1}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaBaseSpeed', name: 'Base Speed', baseCost: 10, costFactor: 2.8, maxLevel: 15, getLevel: () => globalState.metaLevels.baseSpeed, applyEffect: () => { globalState.metaLevels.baseSpeed++; updateAllTvsPostMeta(); }, getDescription: (gs, l, c, maxed) => maxed ? `Max Base Speed (Lv ${l})`:`Lv ${l}: +Speed All TVs<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaBaseMaxBoxes', name: 'Global Capacity', baseCost: 15, costFactor: 3.5, maxLevel: MAX_BOXES_PER_TV,
                getLevel: () => globalState.metaLevels.baseMaxBoxes, applyEffect: () => { globalState.metaLevels.baseMaxBoxes++; updateAllTvsPostMeta(); updateMetaUpgradeButtonsIfVisible(); },
                getDescription: (gs, l, c, maxed) => maxed ? `Max Global Cap (${gs.maxBoxesPerTv})` : `Lv ${l}: Global Max Logos: ${deriveMetaBaseMaxBoxes(l+1)}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaTvSynergyBonus', name: 'TV Synergy', baseCost: 50, costFactor: 2.5, getLevel: () => globalState.metaLevels.tvSynergyBonus, applyEffect: () => { globalState.metaLevels.tvSynergyBonus++; recalculateGlobalSynergy(); updateMetaUpgradeButtonsIfVisible(); },
               getDescription: (gs, l, c) => { const nextLevel = l + 1; const nextPerTvBonus = deriveSynergyBonusPerTv(nextLevel); const currentNumTvs = gs.tvStates.length; const nextTotalBonus = 1.0 + currentNumTvs * nextPerTvBonus; return `Lv ${l}: All Hits x${globalState.synergyBonus.toFixed(3)}<br>(Next: +${(nextPerTvBonus*100).toFixed(2)}% per TV)<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>`; } },
        ];

        // --- Upgrade Calculation Functions ---
        function deriveTvHitValue(tvState, level) { return Math.max(1, Math.ceil(1 + level * 0.75)); }
        function deriveTvSpeedFactor(tvState, level) { return Math.min(3.0, (1 + level * 0.04) * tvState.baseSpeedFactorMeta); }
        function deriveTvCornerFlatBonus(tvState, level) { return Math.max(0, Math.floor(1000 + level * 4 + Math.pow(level, 1.45))); }
        function deriveTvCornerPercentBonus(tvState, level) { return level * 0.00001; }
        function deriveTvCollisionBonus(tvState, level) { return Math.max(0, Math.floor(2 + level * 0.5 + Math.pow(level, 1.2))); }
        function getCurrentTvSpeed(tvState) { return BASE_SPEED_CONSTANT * deriveTvSpeedFactor(tvState, tvState.upgrades.speed); }
        function deriveMetaFragmentMult(level) { return 1 + level * 0.07; }
        function deriveMetaBaseSpeedFactor(level) { return 1 + level * 0.03; }
        function deriveMetaBaseMaxBoxes(level) { return 2 + level; }
        function deriveSynergyBonusPerTv(level) { return level > 0 ? (level * 0.005) : 0; }
        function deriveSynergyBonus(level) { const perTvBonus = deriveSynergyBonusPerTv(level); const numTvs = globalState?.tvStates?.length ?? 0; return 1.0 + (numTvs * perTvBonus); }

        // --- Apply Upgrades ---
        function recalculateDerivedTvState(tvState) { tvState.hitValue = deriveTvHitValue(tvState, tvState.upgrades.hitValue); tvState.cornerHitBaseBonus = deriveTvCornerFlatBonus(tvState, tvState.upgrades.cornerBonusFlat); tvState.cornerHitPercentBonus = deriveTvCornerPercentBonus(tvState, tvState.upgrades.cornerBonusPercent); tvState.boxCollisionValue = deriveTvCollisionBonus(tvState, tvState.upgrades.boxCollisionValue); }
        function recalculateGlobalSynergy() { globalState.synergyBonus = deriveSynergyBonus(globalState.metaLevels.tvSynergyBonus); }
        function applyMetaUpgradesToTv(tvState) { tvState.baseSpeedFactorMeta = deriveMetaBaseSpeedFactor(globalState.metaLevels.baseSpeed); recalculateDerivedTvState(tvState); resizeTvScreen(tvState); }
        function updateAllTvsPostMeta() { globalState.maxBoxesPerTv = deriveMetaBaseMaxBoxes(globalState.metaLevels.baseMaxBoxes); globalState.tvStates.forEach(tv => { applyMetaUpgradesToTv(tv); checkAndAdjustBoxPositions(tv.index); }); recalculateGlobalSynergy(); updateAllTvGlows(); }

        // --- Upgrade UI & Modal Logic ---
        function openUpgradeModal(tvIndex = -1) {
            selectedTvIndex = tvIndex; modalUpgradesContainer.innerHTML = ''; modalRebootContainer.innerHTML = ''; modalBuyAmountContainer.innerHTML = '';
            if (tvIndex !== -1) {
                const tvState = globalState.tvStates[tvIndex]; if (!tvState) return;
                modalTitle.textContent = `TV #${tvState.id} Upgrades`; updateModalTvStats(tvState);
                renderBuyAmountButtons(); renderUpgradeSection(tvUpgrades, modalUpgradesContainer, 'hit', tvIndex);
            } else {
                modalTitle.textContent = 'Meta Upgrades & Reboot'; modalTvStats.textContent = `Fragments: ${formatScore(globalState.systemFragments)}`;
                renderUpgradeSection(metaUpgrades, modalUpgradesContainer, 'meta');
                const potentialGain = calculateFragmentGain(globalState.lifetimeSessionHits);
                if (potentialGain > 0 || globalState.hasRebootedOnce) {
                    const rebootTemplate = document.getElementById('reboot-section-template'); if (rebootTemplate) { const clonedReboot = rebootTemplate.firstElementChild.cloneNode(true); const rebootBtn = clonedReboot.querySelector('#reboot-button'); if (rebootBtn) { rebootBtn.onclick = executeReboot; } modalRebootContainer.appendChild(clonedReboot); updateRebootPreviewIfVisible(); } else { console.error("Reboot template not found!"); }
                }
            } upgradeModal.classList.add('show');
        }
        function closeUpgradeModal() { upgradeModal.classList.remove('show'); selectedTvIndex = -1; updateAllTvGlows(); }
        function renderBuyAmountButtons() {
            modalBuyAmountContainer.innerHTML = ''; const amounts = [1, 10, 100, 'max'];
            amounts.forEach(amount => {
                const btn = document.createElement('button'); btn.classList.add('buy-amount-button'); btn.textContent = `${amount === 'max' ? 'Max' : 'x'+amount}`; btn.dataset.amount = amount;
                if (selectedBuyAmount === amount || (selectedBuyAmount === Infinity && amount === 'max')) { btn.classList.add('active'); }
                btn.onclick = () => setBuyAmount(amount); modalBuyAmountContainer.appendChild(btn);
            });
        }
        function setBuyAmount(amount) {
            selectedBuyAmount = (amount === 'max') ? Infinity : amount;
            const buttons = modalBuyAmountContainer.querySelectorAll('.buy-amount-button');
            buttons.forEach(btn => { const btnAmount = btn.dataset.amount; const isActive = (selectedBuyAmount === Infinity && btnAmount === 'max') || (selectedBuyAmount === parseInt(btnAmount)); btn.classList.toggle('active', isActive); });
            updateSelectedTvUpgradeButtons();
        }
        function calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex) {
            const amountToTry = selectedBuyAmount; const currentLevel = upgrade.getLevel(tvState);
            let totalCost = 0; let levelsBought = 0; let maxLevelReached = false; let canAfford = false;
            const maxIterations = (amountToTry === Infinity) ? MAX_BULK_BUY_CHECK : amountToTry;

            for (let i = 0; i < maxIterations; i++) {
                const levelToCheck = currentLevel + i;
                let maxLevel; if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv; else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(tvState); else maxLevel = upgrade.maxLevel;
                if (maxLevel !== undefined && levelToCheck >= maxLevel) { maxLevelReached = true; break; }
                let canPurchaseCheck = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, levelToCheck) : true; if (!canPurchaseCheck) { maxLevelReached = true; break; }
                const costForThisLevel = calculateCost(upgrade.baseCost, levelToCheck, upgrade.costFactor, tvIndex);
                if (currentScore >= totalCost + costForThisLevel) { totalCost += costForThisLevel; levelsBought++; canAfford = true; }
                else { break; }
            }

            if (levelsBought === 0) {
                let isCurrentlyMax = false; let maxLevelCheck; if (upgrade.id === 'multiBox') maxLevelCheck = globalState.maxBoxesPerTv; else if (typeof upgrade.getMaxLevel === 'function') maxLevelCheck = upgrade.getMaxLevel(tvState); else maxLevelCheck = upgrade.maxLevel; if (maxLevelCheck !== undefined && currentLevel >= maxLevelCheck) isCurrentlyMax = true;
                let canPurchaseCurrent = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, currentLevel) : true; if (!canPurchaseCurrent) isCurrentlyMax = true;
                 if (!isCurrentlyMax) { totalCost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor, tvIndex); canAfford = currentScore >= totalCost; }
                 else { canAfford = false; } maxLevelReached = isCurrentlyMax;
            }
            return { levels: levelsBought, totalCost: totalCost, affordable: canAfford && levelsBought > 0, isMaxLevel: maxLevelReached && levelsBought === 0 };
        }
        function renderUpgradeSection(upgrades, container, currencyType, tvIndex = -1) {
             if (!container) return; container.innerHTML = '';
             const isTvModal = currencyType === 'hit' && tvIndex !== -1;
             const tvState = isTvModal ? globalState.tvStates[tvIndex] : null;
             const stateForLevel = tvState ?? globalState;
             const currentScore = currencyType === 'hit' ? globalState.totalSessionHits : globalState.systemFragments;

             upgrades.forEach(upgrade => {
                 const currentLevel = upgrade.getLevel(stateForLevel);
                 let bulkInfo = { levels: 1, totalCost: 0, affordable: false, isMaxLevel: false };
                 let descriptionText = ''; let currencyClass = currencyType;

                 let maxLevelCheck; if (upgrade.id === 'multiBox') maxLevelCheck = globalState.maxBoxesPerTv; else if (typeof upgrade.getMaxLevel === 'function') maxLevelCheck = upgrade.getMaxLevel(tvState); else maxLevelCheck = upgrade.maxLevel;
                 let isCurrentlyMaxed = (maxLevelCheck !== undefined && currentLevel >= maxLevelCheck);
                 let canPurchaseCurrent = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, currentLevel) : true;
                 if (!canPurchaseCurrent) isCurrentlyMaxed = true;

                 if (isTvModal && !isCurrentlyMaxed) {
                     bulkInfo = calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex);
                     descriptionText = upgrade.getDescription(tvState, currentLevel, false);
                 } else if (isTvModal && isCurrentlyMaxed) {
                     bulkInfo.isMaxLevel = true; bulkInfo.affordable = false; bulkInfo.totalCost = 0;
                     descriptionText = upgrade.getDescription(tvState, currentLevel, true);
                 } else { // Meta
                     const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor);
                     bulkInfo.totalCost = cost; bulkInfo.levels = 1;
                     bulkInfo.affordable = currentScore >= cost && !isCurrentlyMaxed;
                     bulkInfo.isMaxLevel = isCurrentlyMaxed;
                     descriptionText = upgrade.getDescription(globalState, currentLevel, cost, bulkInfo.isMaxLevel);
                 }

                 const btn = document.createElement('button'); btn.classList.add('upgrade-button');
                 btn.dataset.upgradeId = upgrade.id; btn.dataset.currencyType = currencyType;
                 if (tvIndex >= 0) btn.dataset.tvIndex = tvIndex;

                 if (isTvModal) {
                     btn.innerHTML = `<div class="upgrade-description">${descriptionText}</div>`;
                     if (!isCurrentlyMaxed) { btn.innerHTML += `<div class="upgrade-cost ${currencyClass}">Cost: ${formatScore(bulkInfo.totalCost)} ${bulkInfo.levels > 1 ? `(x${bulkInfo.levels})` : ''}</div>`; }
                 } else { btn.innerHTML = `<div class="upgrade-description">${descriptionText}</div>`; }

                 btn.disabled = isCurrentlyMaxed || !bulkInfo.affordable;
                 btn.onclick = () => buyUpgrade(upgrade.id, currencyType, tvIndex);
                 container.appendChild(btn);
             });
        }
        function updateUpgradeButtonsInSection(upgrades, container, currencyType, tvIndex = -1) {
            if (!container) return;
            const isTvModal = currencyType === 'hit' && tvIndex !== -1;
            const tvState = isTvModal ? globalState.tvStates[tvIndex] : null;
            const currentScore = currencyType === 'hit' ? globalState.totalSessionHits : globalState.systemFragments;

            upgrades.forEach(upgrade => {
                const btn = container.querySelector(`[data-upgrade-id="${upgrade.id}"]`);
                if (btn) {
                    const currentLevel = upgrade.getLevel(tvState ?? globalState);
                    let bulkInfo = { levels: 1, totalCost: 0, affordable: false, isMaxLevel: false };
                    let descriptionText = ''; let currencyClass = currencyType;

                    let maxLevelCheck; if (upgrade.id === 'multiBox') maxLevelCheck = globalState.maxBoxesPerTv; else if (typeof upgrade.getMaxLevel === 'function') maxLevelCheck = upgrade.getMaxLevel(tvState); else maxLevelCheck = upgrade.maxLevel;
                    let isCurrentlyMaxed = (maxLevelCheck !== undefined && currentLevel >= maxLevelCheck);
                    let canPurchaseCurrent = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, currentLevel) : true;
                    if (!canPurchaseCurrent) isCurrentlyMaxed = true;

                    const descDiv = btn.querySelector('.upgrade-description');
                    let costDiv = btn.querySelector('.upgrade-cost');

                    if (isTvModal && !isCurrentlyMaxed) {
                        bulkInfo = calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex);
                        descriptionText = upgrade.getDescription(tvState, currentLevel, false);
                        if (descDiv) descDiv.innerHTML = descriptionText;
                        if (!costDiv) { costDiv = document.createElement('div'); costDiv.classList.add('upgrade-cost', currencyClass); btn.appendChild(costDiv); }
                        costDiv.innerHTML = `Cost: ${formatScore(bulkInfo.totalCost)} ${bulkInfo.levels > 1 ? `(x${bulkInfo.levels})` : ''}`;
                        costDiv.style.display = '';
                    } else if (isTvModal && isCurrentlyMaxed) {
                         bulkInfo.isMaxLevel = true; bulkInfo.affordable = false;
                         descriptionText = upgrade.getDescription(tvState, currentLevel, true);
                         if (descDiv) descDiv.innerHTML = descriptionText;
                         if (costDiv) costDiv.style.display = 'none';
                    } else { // Meta
                        const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor);
                        bulkInfo.totalCost = cost; bulkInfo.levels = 1;
                        bulkInfo.affordable = currentScore >= cost && !isCurrentlyMaxed;
                        bulkInfo.isMaxLevel = isCurrentlyMaxed;
                        descriptionText = upgrade.getDescription(globalState, currentLevel, cost, bulkInfo.isMaxLevel);
                        if (descDiv) descDiv.innerHTML = descriptionText;
                    }
                    btn.disabled = isCurrentlyMaxed || !bulkInfo.affordable;
                }
            });
        }
        function buyUpgrade(id, currencyType, tvIndex = -1) {
            const upgrades = currencyType === 'hit' ? tvUpgrades : metaUpgrades;
            const upgrade = upgrades.find(u => u.id === id); if (!upgrade) return;

            const isTvUpgrade = currencyType === 'hit' && tvIndex !== -1;
            const amountToTry = isTvUpgrade ? selectedBuyAmount : 1;

            const stateToModify = tvIndex !== -1 ? globalState.tvStates[tvIndex] : globalState;
            const scoreRef = currencyType === 'hit' ? 'totalSessionHits' : 'systemFragments';

            let currentLevel = upgrade.getLevel(stateToModify);
            let totalCost = 0;
            let levelsToBuy = 0;

            const maxIterations = (amountToTry === Infinity) ? MAX_BULK_BUY_CHECK : amountToTry;

            for (let i = 0; i < maxIterations; i++) {
                const levelToCheck = currentLevel + i;
                let maxLevel; if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv; else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(stateToModify); else maxLevel = upgrade.maxLevel;
                if (maxLevel !== undefined && levelToCheck >= maxLevel) break;
                let canPurchaseCheck = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(stateToModify, levelToCheck) : true; if (!canPurchaseCheck) break;
                const costForThisLevel = calculateCost(upgrade.baseCost, levelToCheck, upgrade.costFactor, tvIndex);
                if (Math.floor(globalState[scoreRef]) >= totalCost + costForThisLevel) { totalCost += costForThisLevel; levelsToBuy++; } else { break; }
            }

            if (levelsToBuy > 0) {
                globalState[scoreRef] -= totalCost;

                if (isTvUpgrade) {
                    if (upgrade.id === 'multiBox') {
                        upgrade.applyEffect(stateToModify, tvIndex, levelsToBuy);
                    } else {
                         const levelProp = Object.keys(stateToModify.upgrades).find(k => k === upgrade.id);
                         if (levelProp && typeof stateToModify.upgrades[levelProp] === 'number') {
                             stateToModify.upgrades[levelProp] += levelsToBuy;
                         } else {
                             console.warn(`Could not directly set level for TV upgrade ${upgrade.id}. Applying effect ${levelsToBuy} times.`);
                             for(let k=0; k<levelsToBuy; k++) { upgrade.applyEffect(stateToModify, tvIndex); }
                         }
                    }
                    recalculateDerivedTvState(stateToModify);
                    updateModalTvStats(stateToModify);
                    updateSelectedTvUpgradeButtons();
                    updateTvGlow(tvIndex);
                } else {
                     upgrade.applyEffect(stateToModify, tvIndex);
                     if (upgrade.id === 'metaTvSynergyBonus' || upgrade.id === 'metaAddTv') recalculateGlobalSynergy();
                     if (upgrade.id === 'metaBaseMaxBoxes' || upgrade.id === 'metaBaseSpeed') updateAllTvsPostMeta();
                     modalTvStats.textContent = `Fragments: ${formatScore(globalState.systemFragments)}`;
                     updateMetaUpgradeButtonsIfVisible();
                     if (selectedTvIndex !== -1) updateSelectedTvUpgradeButtons();
                     updateAllTvGlows();
                }
                updateTotalHitsDisplay();
                saveGame();
            }
        }

        // --- Button Updates ---
        function updateSelectedTvUpgradeButtons() { if (selectedTvIndex !== -1 && upgradeModal.classList.contains('show')) { updateUpgradeButtonsInSection(tvUpgrades, modalUpgradesContainer, 'hit', selectedTvIndex); } }
        function updateMetaUpgradeButtonsIfVisible() { if (selectedTvIndex === -1 && upgradeModal.classList.contains('show')) { updateUpgradeButtonsInSection(metaUpgrades, modalUpgradesContainer, 'meta'); updateRebootPreviewIfVisible(); } }

        // --- Reboot Logic ---
        function canCurrentlyReboot() { return globalState.systemFragments > 0 || globalState.hasRebootedOnce || calculateFragmentGain(globalState.lifetimeSessionHits) > 0; }
        function checkMetaButtonVisibility() { metaMenuButton.classList.toggle('show', canCurrentlyReboot()); }
        function updateRebootPreviewIfVisible() { if (selectedTvIndex !== -1 || !upgradeModal.classList.contains('show')) return; const rebootSection = modalRebootContainer.querySelector('#reboot-section'); if (!rebootSection) return; const rebootGainPreview = rebootSection.querySelector('#reboot-gain-preview'); const rebootButton = rebootSection.querySelector('#reboot-button'); if (!rebootGainPreview || !rebootButton) return; const gain = calculateFragmentGain(globalState.lifetimeSessionHits); rebootGainPreview.textContent = `Gain ~${formatScore(gain)} Fragments (from ${formatScore(globalState.lifetimeSessionHits)} total Hits)`; rebootButton.disabled = gain <= 0; }
        function calculateFragmentGain(totalLifetimeHits) { if (totalLifetimeHits < 5000) return 0; const metaMultiplier = deriveMetaFragmentMult(globalState.metaLevels.fragmentGain); const baseGain = Math.pow(totalLifetimeHits / 5000, 0.45) * 1.5; const logBonus = Math.log10(totalLifetimeHits / 5000 + 1) * 0.5; const gain = Math.floor((baseGain + logBonus) * metaMultiplier); return Math.max(0, gain); }
        function executeReboot() {
             const fragmentsGained = calculateFragmentGain(globalState.lifetimeSessionHits); if (fragmentsGained <= 0) { showNotification("Not enough lifetime Hits for fragments"); return; } if (!confirm(`Reboot: Gain ${formatScore(fragmentsGained)} Fragments?\n\nResets session Hits, Corner Hits & TV Upgrades.\nKeeps Fragments, Meta Upgrades & Unlocked TVs.`)) { return; } closeUpgradeModal(); showNotification(`Rebooted! +${formatScore(fragmentsGained)} Fragments`); globalState.systemFragments += fragmentsGained; globalState.hasRebootedOnce = true; globalState.totalSessionHits = 0; globalState.lifetimeSessionHits = 0;
             globalState.totalCornerHits = 0;
             boxCollisionTimers = {};
             globalState.tvStates.forEach((tvState, index) => { Object.keys(tvState.upgrades).forEach(key => { tvState.upgrades[key] = 0; }); tvState.boxes = []; tvState.nextBoxId = 0; clearTvScreenBoxes(index); recalculateDerivedTvState(tvState); applyMetaUpgradesToTv(tvState); addBoxToTv(index); resizeTvScreen(tvState); checkAndAdjustBoxPositions(index); });
             recalculateGlobalSynergy(); updateTotalHitsDisplay(); updateTotalCornerHitsDisplay();
             updateAllTvGlows(); checkMetaButtonVisibility(); saveGame();
         }

        // --- Saving and Loading ---
        function saveGame() {
            try {
                if (document.hidden) return;
                 if (!globalState) {
                     console.warn("Attempted to save with null globalState.");
                     return;
                 }

                const amountToSave = (selectedBuyAmount === Infinity) ? 'max' : selectedBuyAmount;
                const stateToSave = JSON.parse(JSON.stringify({...globalState, selectedBuyAmount: amountToSave}, (key, value) => {
                    if (key === 'elements' || key === 'element') return undefined;
                     if (key === 'x' || key === 'y' || key === 'vx' || key === 'vy') {
                         return (typeof value === 'number' && !isNaN(value)) ? value : 0;
                     }
                    return value;
                }));
                localStorage.setItem(SAVE_KEY, JSON.stringify(stateToSave));
            } catch (e) {
                console.error("Save Error:", e);
                showNotification("Save Error!");
            }
        }
        function loadGame() {
            const savedData = localStorage.getItem(SAVE_KEY);
            let needsInitialization = true;
            if (savedData) {
                try {
                    const loadedState = JSON.parse(savedData);
                    if (typeof loadedState.systemFragments === 'number' && Array.isArray(loadedState.tvStates) && loadedState.metaLevels) {
                        globalState = createDefaultGlobalState();
                        globalState = deepMerge(globalState, loadedState);

                        if (typeof globalState.totalSessionHits !== 'number' || isNaN(globalState.totalSessionHits)) globalState.totalSessionHits = 0;
                        if (typeof globalState.lifetimeSessionHits !== 'number' || isNaN(globalState.lifetimeSessionHits)) globalState.lifetimeSessionHits = globalState.totalSessionHits || 0;
                        if (typeof globalState.totalCornerHits !== 'number' || isNaN(globalState.totalCornerHits)) globalState.totalCornerHits = 0;
                        if (typeof globalState.hasRebootedOnce !== 'boolean') globalState.hasRebootedOnce = globalState.systemFragments > 0;
                        if (typeof globalState.nextTvId !== 'number' || isNaN(globalState.nextTvId)) globalState.nextTvId = (globalState.tvStates.reduce((max, tv) => Math.max(max, tv.id ?? -1), -1) + 1);
                        if (globalState.metaLevels.hasOwnProperty('logoSize')) { delete globalState.metaLevels.logoSize; }

                        selectedBuyAmount = globalState.selectedBuyAmount || 1;
                        if (selectedBuyAmount === 'max') selectedBuyAmount = Infinity;
                        else selectedBuyAmount = parseInt(selectedBuyAmount) || 1;

                        globalState.tvStates.forEach((tv, index) => {
                            tv.index = index;
                            tv.boxes.forEach(box => {
                                box.x = (typeof box.x === 'number' && !isNaN(box.x)) ? box.x : 50;
                                box.y = (typeof box.y === 'number' && !isNaN(box.y)) ? box.y : 50;
                                box.vx = (typeof box.vx === 'number' && !isNaN(box.vx)) ? box.vx : (Math.random()-0.5)*BASE_SPEED_CONSTANT*0.5;
                                box.vy = (typeof box.vy === 'number' && !isNaN(box.vy)) ? box.vy : (Math.random()-0.5)*BASE_SPEED_CONSTANT*0.5;
                            });
                        });
                        nextTvId = globalState.nextTvId;
                        boxCollisionTimers = {};

                        updateAllTvsPostMeta();
                        globalState.tvStates.forEach(applyMetaUpgradesToTv);
                        recalculateGlobalSynergy();

                        showNotification("Loaded Game State");
                        needsInitialization = false;
                    } else {
                        console.warn("Invalid save data structure found, resetting.", loadedState);
                        localStorage.removeItem(SAVE_KEY);
                    }
                } catch (e) {
                    console.error("Load Error:", e);
                    showNotification("Load Error! Resetting.");
                    localStorage.removeItem(SAVE_KEY);
                }
            }

            if (needsInitialization) {
                console.log("No valid save found or load error, initializing new game.");
                globalState = createDefaultGlobalState();
                updateAllTvsPostMeta();
                recalculateGlobalSynergy();
                addTv();
                selectedBuyAmount = 1;
            }

             recreateAllDomElements();
             checkMetaButtonVisibility();
             updateTotalHitsDisplay();
             updateTotalCornerHitsDisplay();
             updateAllTvGlows();
             requestAnimationFrame(handleGlobalResize);
        }

        // --- Utility: Deep Merge ---
        function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }
        function deepMerge(target, source) {
            if (!isObject(target) || !isObject(source)) return source;
            let output = { ...target };
            Object.keys(source).forEach(key => {
                const targetValue = target[key];
                const sourceValue = source[key];
                if (sourceValue === undefined || sourceValue === null) {
                    return;
                }
                if (isObject(sourceValue)) {
                    if (isObject(targetValue)) {
                        output[key] = deepMerge(targetValue, sourceValue);
                    } else {
                        output[key] = JSON.parse(JSON.stringify(sourceValue));
                    }
                } else if (Array.isArray(sourceValue)) {
                    output[key] = JSON.parse(JSON.stringify(sourceValue));
                } else {
                    output[key] = sourceValue;
                }
            });
            return output;
        }


        // --- State Initialization ---
        function createDefaultTvState(index, id) {
            const tvState = {
                index: index,
                id: id,
                boxes: [],
                nextBoxId: 0,
                upgrades: { hitValue: 0, speed: 0, cornerBonusFlat: 0, cornerBonusPercent: 0, boxCollisionValue: 0 },
                hitValue: 1,
                cornerHitBaseBonus: 1000,
                cornerHitPercentBonus: 0,
                boxCollisionValue: 2,
                baseSpeedFactorMeta: 1.0,
                screenWidth: 0, screenHeight: 0,
                dynamicBoxWidth: 0, dynamicBoxHeight: 0,
                elements: null,
            };
            recalculateDerivedTvState(tvState);
            return tvState;
        }
        function createDefaultGlobalState() {
            return {
                systemFragments: 0,
                totalSessionHits: 0,
                lifetimeSessionHits: 0,
                totalCornerHits: 0,
                tvStates: [],
                metaLevels: { fragmentGain: 0, baseSpeed: 0, baseMaxBoxes: 0, tvSynergyBonus: 0 },
                synergyBonus: 1.0,
                maxBoxesPerTv: 2,
                hasRebootedOnce: false,
                nextTvId: 0,
                selectedBuyAmount: 1
            };
        }

        // --- Idle Progress Calculation ---
        function calculateIdleGains(idleTimeMs) {
            if (!globalState || !globalState.tvStates || idleTimeMs <= 0) return 0;
            let totalIdleHitsPerSec = 0;
            globalState.tvStates.forEach(tvState => {
                if (tvState.boxes.length === 0) return;
                recalculateDerivedTvState(tvState);
                const tvSpeedFactor = deriveTvSpeedFactor(tvState, tvState.upgrades.speed);
                const tvHitValue = tvState.hitValue;
                const numBoxes = tvState.boxes.length;
                const hitsPerSecPerBox = IDLE_HITS_PER_SEC_PER_BOX_BASE_FACTOR * tvSpeedFactor;
                const idleHitsPerTvPerSec = numBoxes * hitsPerSecPerBox * tvHitValue;
                totalIdleHitsPerSec += idleHitsPerTvPerSec;
            });
            const totalEffectiveIdleHitsPerSec = totalIdleHitsPerSec * globalState.synergyBonus * DEV_SPEED_FACTOR;
            const totalGainedHits = totalEffectiveIdleHitsPerSec * (idleTimeMs / 1000);
            return Math.floor(totalGainedHits);
        }

        // --- Handle Visibility Change for Idle ---
        function handleVisibilityChange() {
            const now = performance.now();
            if (document.hidden) {
                timeHidden = now;
                saveGame();
            } else {
                if (timeHidden !== null) {
                    const idleTimeMs = now - timeHidden;
                    if (idleTimeMs > 1000) {
                        const gainedHits = calculateIdleGains(idleTimeMs);
                        if (gainedHits > 0) {
                            globalState.totalSessionHits += gainedHits;
                            globalState.lifetimeSessionHits += gainedHits;
                            showNotification(`Gained ${formatScore(gainedHits)} Hits while idle.`);
                            updateTotalHitsDisplay();
                            updateAllTvGlows();
                        }
                    }
                    timeHidden = null;
                }
                lastTimestamp = now;
                 requestAnimationFrame(handleGlobalResize);
            }
        }


        // --- Initialization ---
        async function init() {
             const startTime = performance.now();
             console.log("DVD Multiverse Core Initializing...");

             try {
                 console.log("Preloading images...");
                 await preloadImages([DVD_LOGO_URL, TV_BACKGROUND_URL]);
                 console.log("Images preloaded.");
             } catch (error) {
                 console.error("Image preloading issues:", error);
             }

             loadGame(); // Load/initialize state and create DOM elements

             modalCloseButton.addEventListener('click', closeUpgradeModal);
             upgradeModal.addEventListener('click', (e) => { if (e.target === upgradeModal) closeUpgradeModal(); });
             metaMenuButton.addEventListener('click', () => openUpgradeModal(-1));
             window.addEventListener('resize', handleGlobalResize);
             document.addEventListener('visibilitychange', handleVisibilityChange);

             lastTimestamp = performance.now();
             lastSaveTime = Date.now();
             gameLoopInterval = setInterval(() => gameLoop(performance.now()), TICK_RATE_MS);
             console.log("Initialization complete.");

             // --- Loading screen minimum time ---
             const endTime = performance.now();
             const elapsedTime = endTime - startTime;
             const delayTime = Math.max(0, MIN_LOADING_TIME_MS - elapsedTime);

             console.log(`Initialization took ${elapsedTime.toFixed(0)}ms. Delaying hide by ${delayTime.toFixed(0)}ms.`);

             setTimeout(() => {
                 if (loadingScreen) {
                     loadingScreen.classList.add('hidden');
                     // Remove the loading screen element after the fade-out
                     setTimeout(() => {
                         if (loadingScreen && loadingScreen.parentNode) {
                              loadingScreen.parentNode.removeChild(loadingScreen);
                         }
                     }, 500); // Match the CSS transition duration
                 }
             }, delayTime);
        }

        // --- Start ---
        if (document.readyState === 'loading') {
             document.addEventListener('DOMContentLoaded', init);
        } else {
             init();
        }

    })();
</script>

</body>
</html>
