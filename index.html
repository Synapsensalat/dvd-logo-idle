
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DVD Video Idle</title>
    <style>
        /* Import Futura font if needed (example using Google Fonts - replace if hosted elsewhere) */
        /* @import url('https://fonts.googleapis.com/css2?family=Futura:wght@500&display=swap'); */
        /* Note: Futura isn't freely available on Google Fonts. Use a suitable alternative or ensure it's licensed/hosted. */
        /* Using common fallbacks for now. */

        :root {
            --tv-bg: #282828;
            --screen-bg: #111;
            --text-color: #eee;
            --border-color: #444;
            --highlight-color-hits: #0df; /* Teal */
            --highlight-color-corners: #0f0;
            --highlight-color-wall: #0df;
            --meta-color: #f0f; /* Pink */
            --collision-color: #f90;
            --tv-hover-light: #f50;
            --tv-upgrade-light: var(--highlight-color-hits);
            --modal-bg-translucent: rgba(25, 25, 25, 0.92);
            --modal-border: #555;
            --button-bg: #4a4a4a;
            --button-hover: #666;
            --button-active: #777;
            --disabled-color: #777;
            --accent-color: #eee;
            --main-bg-color: #000;
        }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--main-bg-color);
            font-family: 'Courier New', Courier, monospace; color: var(--text-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
        }

        /* --- Loading Screen Styles --- */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--main-bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
            opacity: 1;
        }

        /* Container for the masked logo */
        #loading-screen .loading-logo-container {
            width: 50%;
            max-width: 350px;
            aspect-ratio: 960 / 500; /* Match the source image aspect ratio */
            margin-bottom: 20px;
            /* Set the desired background color (Teal) */
            background-color: var(--highlight-color-hits);
            /* Apply the mask */
            mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            -webkit-mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
            mask-position: center;
            -webkit-mask-position: center;
        }
         /* Hide the actual img tag content within the container */
        #loading-screen .loading-logo-container img {
            opacity: 0; /* Hide the original image content */
            width: 100%; /* Make it fill the container for sizing */
            height: 100%;
            display: block;
        }

        #loading-screen .loading-text {
             /* START CHANGE: Font Change */
            font-family: 'Futura Medium', Futura, 'Century Gothic', AppleGothic, sans-serif; /* Use Futura Medium with fallbacks */
             /* END CHANGE */
            font-size: clamp(3rem, 10vw, 5rem);
            color: var(--meta-color); /* Pink */
            font-weight: 500; /* Futura Medium weight is typically 500 */
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 0;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .hidden { /* Utility class */
            display: none !important;
        }
        /* --- End Loading Screen Styles --- */


        #game-container {
            display: flex; flex-direction: column; align-items: center;
            justify-content: flex-start;
            width: 100%; height: 100%; padding: 10px; box-sizing: border-box; position: relative;
        }

        #top-info-bar {
            position: absolute; top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: center; align-items: center;
            gap: 20px;
            z-index: 10; pointer-events: none;
            flex-wrap: wrap;
        }
        .top-info-display {
            font-size: clamp(1.1rem, 2.5vw, 1.6rem); font-weight: bold;
            background-color: rgba(10, 10, 10, 0.6); padding: 3px 10px;
            border-radius: 5px; flex-shrink: 0; text-align: center;
        }
        #total-hits-display {
            color: var(--highlight-color-hits);
            text-shadow: 0 0 5px var(--highlight-color-hits);
        }
        #total-corner-hits-display {
            color: var(--highlight-color-corners);
            text-shadow: 0 0 5px var(--highlight-color-corners);
        }

        #tvs-display-area {
            display: flex; flex-wrap: wrap; justify-content: center;
            align-items: flex-start;
            gap: 15px;
            width: 100%; max-width: 1400px;
            padding: 15px; box-sizing: border-box;
            margin-top: 65px;
            max-height: calc(100vh - 90px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tv-instance-container {
            display: flex; flex-direction: column; align-items: center;
            width: clamp(300px, 35vw, 420px);
            flex-shrink: 0; position: relative;
        }

        .tv-frame {
            background-image: url('https://00s.myretrotvs.com/img/tvbackclean.webp');
            background-size: 100% calc(100% / 0.84);
            background-position: center top;
            background-repeat: no-repeat;
            position: relative;
            width: 100%;
            aspect-ratio: 1.25 / 0.84;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s ease;
            overflow: hidden;
        }

        .tv-screen {
            position: absolute;
            top: 9.4%;
            height: 74.1%;
            left: 12%;
            width: 76%;
            background-color: var(--screen-bg);
            overflow: hidden;
            border-radius: 5px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
            filter: url(#crt-effect);
        }

        .tv-screen::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.20) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.04), rgba(0, 255, 0, 0.015), rgba(0, 0, 255, 0.04)); background-size: 100% 2px, 3px 100%; z-index: 2; pointer-events: none; animation: crt-scanline 100s linear infinite; }
        @keyframes crt-scanline { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

        .box { position: absolute; background-color: #ffffff; /* Color set dynamically */ mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png'); -webkit-mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png'); mask-size: contain; -webkit-mask-size: contain; mask-repeat: no-repeat; -webkit-mask-repeat: no-repeat; mask-position: center; -webkit-mask-position: center; z-index: 1; filter: brightness(1.05); will-change: transform; }

        .spark-particle { position: absolute; width: 2px; height: 2px; border-radius: 50%; pointer-events: none; z-index: 10; opacity: 1; background-color: #fff; transition: transform 0.6s cubic-bezier(0.1, 0.7, 0.9, 1), opacity 0.6s ease-out; box-shadow: 0 0 3px #fff; }

        .tv-power-light {
            position: absolute;
            bottom: 2%;
            left: 53%;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #330800;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.5);
            opacity: 0;
            transition: background-color 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            z-index: 5;
        }

        .tv-frame:hover .tv-power-light {
            opacity: 1;
            background-color: var(--tv-hover-light);
            box-shadow: 0 0 5px 2px var(--tv-hover-light),
                        0 0 8px 3px rgba(255, 80, 0, 0.5),
                        inset 0 0 2px rgba(255, 255, 255, 0.3);
        }

        .tv-frame.can-upgrade-glow .tv-power-light {
            opacity: 1;
            background-color: var(--tv-upgrade-light);
            box-shadow: 0 0 6px 3px var(--tv-upgrade-light),
                        0 0 10px 4px rgba(0, 221, 255, 0.6),
                        inset 0 0 2px rgba(255, 255, 255, 0.4);
        }

        #upgrade-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; z-index: 1000; }
        #upgrade-modal.show { display: flex; }
        .modal-content { background-color: var(--modal-bg-translucent); padding: 20px 25px; border-radius: 10px; border: 1px solid var(--modal-border); box-shadow: 0 5px 25px rgba(0,0,0,0.5); width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; position: relative; }
        .modal-header { font-size: clamp(1.2rem, 3vw, 1.6rem); font-weight: bold; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); text-align: center; color: var(--accent-color); }
        .modal-header .tv-stats { font-size: 0.7em; font-weight: normal; color: #bbb; display: block; margin-top: 5px; }
        .modal-close-button { position: absolute; top: 10px; right: 15px; font-size: 1.8rem; color: var(--disabled-color); background: none; border: none; cursor: pointer; padding: 0; line-height: 1; }
        .modal-close-button:hover { color: var(--text-color); }
        #modal-buy-amount-container { display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; }
        .buy-amount-button { background-color: var(--button-bg); color: var(--accent-color); border: 1px solid var(--border-color); padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: background-color 0.2s; }
        .buy-amount-button:hover { background-color: var(--button-hover); }
        .buy-amount-button.active { background-color: var(--button-active); border-color: #999; font-weight: bold; }
        .upgrades-section { display: grid; grid-template-columns: repeat(auto-fit, minmax(125px, 1fr)); gap: 10px; width: 100%; margin-bottom: 15px;}
        .upgrade-button { background-color: var(--button-bg); color: var(--accent-color); border: 1px solid var(--border-color); padding: 10px 6px; border-radius: 6px; cursor: pointer; font-size: clamp(0.7rem, 2vw, 0.85rem); transition: background-color 0.2s, transform 0.1s; text-align: center; min-height: 65px; display: flex; flex-direction: column; justify-content: space-between; align-items: center; }
        .upgrade-button:hover:not(:disabled) { background-color: var(--button-hover); }
        .upgrade-button:active:not(:disabled) { transform: scale(0.96); }
        .upgrade-button:disabled { background-color: #333; color: var(--disabled-color); cursor: not-allowed; opacity: 0.6; }
        .upgrade-description { flex-grow: 1; margin-bottom: 4px; }
        .upgrade-cost { font-size: 0.9em; font-weight: bold; margin-top: auto; }
        .upgrade-cost.hit { color: var(--highlight-color-hits); }
        .upgrade-cost.meta { color: var(--meta-color); }
        /* Ensure cost is visible even when disabled, just dimmer */
        .upgrade-button:disabled .upgrade-cost { color: var(--disabled-color); opacity: 0.8; }
        #modal-reboot-section-container { width: 100%; }
        #reboot-section { border-top: 1px dashed var(--meta-color); margin-top: 15px; padding-top: 15px; text-align: center; }
        #reboot-info { margin-bottom: 8px; font-size: 0.85em; color: #ccc; }
        #reboot-gain-preview { margin-bottom: 12px; font-weight: bold; font-size: 0.9em; }
        #reboot-button { background-color: var(--meta-color); color: #fff; border: 1px solid #505; padding: 8px 18px; border-radius: 5px; cursor: pointer; font-size: 0.9rem; font-weight: bold; transition: background-color 0.2s, transform 0.1s; }
        #reboot-button:hover:not(:disabled) { background-color: #ff40ff; }
        #reboot-button:active:not(:disabled) { transform: scale(0.96); }
        #reboot-button:disabled { background-color: #606; color: var(--disabled-color); cursor: not-allowed; }
        #meta-menu-button { position: fixed; bottom: 15px; right: 15px; background-color: var(--meta-color); color: white; border: 1px solid #505; border-radius: 50%; width: 45px; height: 45px; font-size: 1.5rem; cursor: pointer; z-index: 900; display: none; justify-content: center; align-items: center; box-shadow: 0 3px 8px rgba(0,0,0,0.4); transition: background-color 0.2s, transform 0.2s; display: none; }
        #meta-menu-button:hover { background-color: #ff40ff; transform: scale(1.1); }
        #meta-menu-button.show { display: flex; }
        #notification { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); background-color: rgba(30, 30, 30, 0.85); color: white; padding: 8px 15px; border-radius: 5px; font-size: 0.85rem; opacity: 0; transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out; pointer-events: none; z-index: 1100; text-align: center; border: 1px solid #555;}
        #notification.show { opacity: 1; top: 25px; }

        .float-text { position: absolute; font-family: 'Courier New', Courier, monospace; font-weight: bold; z-index: 100; pointer-events: none; opacity: 0; white-space: pre; text-align: center; will-change: transform, opacity; }
        .corner-hit-text { top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--highlight-color-corners); font-size: clamp(1.5rem, 4vw, 2.4rem); text-shadow: 1px 1px #111, 0 0 15px var(--highlight-color-corners), 0 0 5px white; animation: cornerHitAnim 1.3s ease-out forwards; z-index: 101; }
        .collision-text { color: var(--collision-color); font-size: clamp(0.9rem, 2.5vw, 1.4rem); text-shadow: 1px 1px #111, 0 0 8px var(--collision-color); animation: floatFadeUp 0.9s ease-out forwards; z-index: 99; }
        .wall-hit-text { color: var(--highlight-color-wall); font-size: clamp(0.8rem, 2.2vw, 1.2rem); text-shadow: 1px 1px #111, 0 0 6px var(--highlight-color-wall); animation: floatFadeUp 0.8s ease-out forwards; z-index: 98; }

        @keyframes floatFadeUp { 0% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -150%) scale(0.8); } }
        @keyframes cornerHitAnim { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(0.95); } 100% { opacity: 0; transform: translate(-50%, -180%) scale(0.7); } }

        svg { position:absolute; height: 0; width: 0; }
    </style>
</head>
<body>

<!-- Loading Screen HTML -->
<div id="loading-screen">
    <div class="loading-logo-container">
         <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png" alt="">
    </div>
    <p class="loading-text">IDLE</p>
</div>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <defs>
    <filter id="crt-effect">
      <feGaussianBlur stdDeviation="0.2" result="blurred"/>
      <feComponentTransfer in="blurred" result="contrastBoost">
         <feFuncR type="linear" slope="1.03" intercept="-0.005"/>
         <feFuncG type="linear" slope="1.03" intercept="-0.005"/>
         <feFuncB type="linear" slope="1.03" intercept="-0.005"/>
      </feComponentTransfer>
    </filter>
  </defs>
</svg>

<div id="game-container">
    <div id="top-info-bar">
        <div id="total-hits-display" class="top-info-display">Hits: 0</div>
      <!-- <div id="total-corner-hits-display" class="top-info-display">Corners: 0</div> -->
    </div>
    <div id="tvs-display-area"></div>
    <button id="meta-menu-button" aria-label="Meta Upgrades & Reboot">✵</button>
</div>

<div id="upgrade-modal">
    <div class="modal-content">
        <button class="modal-close-button" aria-label="Close Modal">×</button>
        <div class="modal-header">
            <span id="modal-title">Upgrades</span>
            <span id="modal-tv-stats" class="tv-stats"></span>
        </div>
        <div id="modal-buy-amount-container"></div>
        <div id="modal-upgrades-section" class="upgrades-section"></div>
        <div id="modal-reboot-section-container"></div>
    </div>
</div>

<div id="reboot-section-template" style="display: none;">
    <div id="reboot-section">
        <div id="reboot-info">Reboot to gain Fragments based on total Hits this session.</div>
        <div id="reboot-gain-preview">Gain ~0 Fragments</div>
        <button id="reboot-button" disabled>Reboot System</button>
    </div>
</div>

<div id="notification"></div>

<script>
    (function() {

        // --- Game Constants ---
        const DEV_SPEED_FACTOR = 1;
        const DVD_LOGO_URL = 'https://upload.wikimedia.org/wikipedia/commons/6/64/DVD_VIDEO_logo.png';
        const TV_BACKGROUND_URL = 'https://00s.myretrotvs.com/img/tvbackclean.webp';
        const BASE_LOGO_HEIGHT_SCREEN_RATIO = 0.14;
        const BASE_BOX_ASPECT_RATIO = 1.6;
        const BASE_SPEED_CONSTANT = 1.0;
        const MAX_BOXES_PER_TV = 15;
        const SAVE_VERSION = 'v0.2'; 
        const SAVE_KEY = `dvdVideoIdleSave_${SAVE_VERSION}`;
        const TICK_RATE_MS = 16;
        const COLLISION_ENERGY_LOSS = 0.96;
        const BOX_COLLISION_COOLDOWN_MS = 100;
        const BOX_COLLISION_SEPARATION_BUFFER = 0.1;
        const TV_COST_SCALING_FACTOR = 1.8;
        const MAX_BULK_BUY_CHECK = 10000;
        const IDLE_HITS_PER_SEC_PER_BOX_BASE_FACTOR = 0.6;
        const MIN_LOADING_TIME_MS = 2000;
        const MIN_OFFLINE_TIME_MS = 60 * 1000; // 1 minute minimum for offline calc
        const MAX_OFFLINE_TIME_MS = 14 * 24 * 60 * 60 * 1000; // 14 days maximum for offline calc

        // --- DOM Element Selection ---
        const loadingScreen = document.getElementById('loading-screen');
        const totalHitsDisplay = document.getElementById('total-hits-display');
        const totalCornerHitsDisplay = document.getElementById('total-corner-hits-display');
        const tvsDisplayArea = document.getElementById('tvs-display-area');
        const notificationElement = document.getElementById('notification');
        const upgradeModal = document.getElementById('upgrade-modal');
        const modalContent = upgradeModal.querySelector('.modal-content');
        const modalCloseButton = upgradeModal.querySelector('.modal-close-button');
        const modalTitle = upgradeModal.querySelector('#modal-title');
        const modalTvStats = upgradeModal.querySelector('#modal-tv-stats');
        const modalBuyAmountContainer = upgradeModal.querySelector('#modal-buy-amount-container');
        const modalUpgradesContainer = upgradeModal.querySelector('#modal-upgrades-section');
        const modalRebootContainer = upgradeModal.querySelector('#modal-reboot-section-container');
        const metaMenuButton = document.getElementById('meta-menu-button');

        // --- Game State ---
        let globalState;
        let selectedTvIndex = -1;
        let gameLoopInterval = null;
        let lastTimestamp = 0; // Used for active game loop delta time (performance.now())
        let lastSaveTime = 0; // Used for periodic saving interval (Date.now())
        let nextTvId = 0;
        let boxCollisionTimers = {};
        let selectedBuyAmount = 1;
        let timeHidden = null; // Used for tab visibility idle calc (performance.now())

        // --- Utility Functions ---
        const calculateCost = (baseCost, level, factor = 1.5, tvIndex = -1) => { let cost = baseCost * Math.pow(factor, level); if (tvIndex >= 0 && tvIndex > 0) { cost *= Math.pow(TV_COST_SCALING_FACTOR, tvIndex); } return Math.max(1, Math.floor(cost)); };
        const formatScore = (value) => { const V = Math.floor(value); if (V < 1e4) return V.toLocaleString(); if (V < 1e6) return (V / 1e3).toFixed(V < 100e3 ? 1 : 0) + 'K'; if (V < 1e9) return (V / 1e6).toFixed(V < 100e6 ? 1 : 0) + 'M'; if (V < 1e12) return (V / 1e9).toFixed(V < 100e9 ? 1 : 0) + 'B'; if (V < 1e15) return (V / 1e12).toFixed(V < 100e12 ? 1 : 0) + 'T'; if (V < 1e18) return (V / 1e15).toFixed(V < 100e15 ? 1 : 0) + 'Qd'; return (V / 1e18).toFixed(1) + 'Qn'; };
        function getRandomColor() { let r, g, b; let color = '#'; const letters = '0123456789ABCDEF'; do { color = '#'; for (let i = 0; i < 6; i++) { color += letters[Math.floor(Math.random() * 16)]; } r = parseInt(color.substring(1, 3), 16); g = parseInt(color.substring(3, 5), 16); b = parseInt(color.substring(5, 7), 16); } while (r + g + b < 450 || (r > 200 && g > 200 && b > 200)); return color; }
        function getBoxCollisionKey(id1, id2) { return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`; }

        // --- Image Preloading ---
        function preloadImages(urls) {
            const promises = urls.map(url => {
                return new Promise((resolve) => { // Always resolve
                    const img = new Image();
                    img.onload = resolve;
                    img.onerror = (err) => {
                        console.error(`Failed to load image: ${url}`, err);
                        resolve(); // Resolve even on error
                    };
                    img.src = url;
                });
            });
            return Promise.all(promises);
        }

        // --- TV & Box Creation / Management ---
        function createTvDom(tvState) {
            const container = document.createElement('div');
            container.classList.add('tv-instance-container');
            container.dataset.tvIndex = tvState.index;

            const tvFrame = document.createElement('div');
            tvFrame.classList.add('tv-frame');
            tvFrame.id = `tv-frame-${tvState.id}`;
            tvFrame.onclick = (e) => { e.stopPropagation(); openUpgradeModal(tvState.index); };

            const tvScreen = document.createElement('div');
            tvScreen.classList.add('tv-screen');
            tvScreen.id = `tv-screen-${tvState.id}`;
            tvFrame.appendChild(tvScreen);

            const powerLight = document.createElement('div');
            powerLight.classList.add('tv-power-light');
            tvFrame.appendChild(powerLight);

            container.appendChild(tvFrame);
            tvsDisplayArea.appendChild(container);

            tvState.elements = {
                container,
                frame: tvFrame,
                screen: tvScreen,
                powerLight: powerLight
            };
            resizeTvScreen(tvState);
            updateTvGlow(tvState.index);
        }

        function createBoxElement(tvState, boxData) {
            if (!tvState.elements || !tvState.elements.screen) {
                console.error("TV screen element not found when creating box for TV", tvState.id);
                return null;
            }
            if (!tvState.screenWidth || !tvState.screenHeight) {
                 console.warn("Screen dimensions not ready for TV", tvState.id, "retrying box creation soon.");
                 // Add a slight delay and retry, only if the element doesn't exist yet
                 if(!boxData.element){
                     setTimeout(() => {
                        if(tvState.boxes.find(b => b.id === boxData.id && !b.element)) {
                            const reBox = tvState.boxes.find(b => b.id === boxData.id);
                            if (reBox && !reBox.element) { // Double check element is still needed
                                reBox.element = createBoxElement(tvState, reBox);
                                if(reBox.element) {
                                    reBox.element.style.transform = `translate(${reBox.x}px, ${reBox.y}px)`;
                                }
                            }
                        }
                     }, 100);
                 }
                 return null;
             }

            const boxElement = document.createElement('div');
            boxElement.classList.add('box');
            boxElement.id = `tv${tvState.id}-box${boxData.id}`;
            boxElement.style.width = `${tvState.dynamicBoxWidth}px`;
            boxElement.style.height = `${tvState.dynamicBoxHeight}px`;
            boxElement.style.transform = `translate(${boxData.x}px, ${boxData.y}px)`;
            boxElement.style.backgroundColor = getRandomColor(); // Set dynamic color here
            boxElement.style.maskImage = `url('${DVD_LOGO_URL}')`;
            boxElement.style.webkitMaskImage = `url('${DVD_LOGO_URL}')`;
            tvState.elements.screen.appendChild(boxElement);
            return boxElement;
        }

        function addBoxToTv(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
            const currentMaxBoxes = globalState.maxBoxesPerTv;
            if (!tvState || tvState.boxes.length >= currentMaxBoxes) return false;

            if (!tvState.elements || !tvState.elements.screen || !tvState.screenWidth || !tvState.screenHeight) {
                 console.warn(`TV ${tvState.id}: Screen dimensions not ready, delaying box add.`);
                 resizeTvScreen(tvState); // Attempt resize first
                 setTimeout(() => addBoxToTv(tvIndex), 100); // Retry after delay
                 return false;
             }

            const id = tvState.nextBoxId++;
            const speed = getCurrentTvSpeed(tvState);
            const baseAngle = Math.PI / 4;
            const randomOffset = (Math.random() - 0.5) * (Math.PI / 6);
            const randomQuadrant = Math.floor(Math.random() * 4);
            const angle = baseAngle + randomOffset + randomQuadrant * (Math.PI / 2);

            let startX, startY, attempts = 0, tooClose;
            do {
                startX = Math.random() * (tvState.screenWidth - tvState.dynamicBoxWidth);
                startY = Math.random() * (tvState.screenHeight - tvState.dynamicBoxHeight);
                tooClose = tvState.boxes.some(eB => {
                    const dx=startX-eB.x; const dy=startY-eB.y;
                    return (dx*dx+dy*dy) < Math.pow(tvState.dynamicBoxWidth*1.5, 2);
                });
                attempts++;
            } while (tooClose && attempts < 10);

            const newBox = {
                id: id,
                x: startX,
                y: startY,
                vx: Math.cos(angle) * speed * 0.7,
                vy: Math.sin(angle) * speed * 0.7,
                element: null
            };

            newBox.element = createBoxElement(tvState, newBox);

            // Check if element creation was successful or delayed
            if (newBox.element || !tvState.screenWidth) { // Add to boxes even if element creation delayed
                 tvState.boxes.push(newBox);
                 updateTvGlow(tvIndex); // Update glow now
                 return true;
            } else {
                 console.warn("Box element creation potentially delayed for TV", tvState.id);
                 // Don't decrement nextBoxId here, let the retry handle element creation
                 tvState.boxes.push(newBox); // Still add the box data
                 updateTvGlow(tvIndex);
                 return true; // Indicate box was added logically, element might follow
            }
        }

        function addTv() {
            const newIndex = globalState.tvStates.length;
            const newId = nextTvId++;
            globalState.nextTvId = nextTvId; // Update global state immediately
            const newTvState = createDefaultTvState(newIndex, newId);
            applyMetaUpgradesToTv(newTvState);
            globalState.tvStates.push(newTvState);
            createTvDom(newTvState);
            addBoxToTv(newIndex); // This might return before the box is fully rendered if screen size isn't ready
            recalculateGlobalSynergy();
            updateMetaUpgradeButtonsIfVisible();
            updateAllTvGlows();
            showNotification(`TV #${newId} Online`);
            return newTvState;
        }
        function removeAllDomElements() { tvsDisplayArea.innerHTML = ''; globalState.tvStates.forEach(tv => tv.elements = null); }
        function recreateAllDomElements() {
             removeAllDomElements();
             globalState.tvStates.forEach(tvState => {
                createTvDom(tvState);
                tvState.boxes.forEach(box => {
                    if (typeof box.x !== 'number' || typeof box.y !== 'number' || typeof box.vx !== 'number' || typeof box.vy !== 'number' || isNaN(box.x) || isNaN(box.y) || isNaN(box.vx) || isNaN(box.vy)) {
                        console.warn(`Invalid box data on load for TV ${tvState.id} box ${box.id}. Resetting position/velocity.`);
                        box.x = 50; box.y = 50; box.vx = (Math.random()-0.5)*0.5; box.vy = (Math.random()-0.5)*0.5;
                    }
                    box.element = null; // Ensure element is recreated
                    box.element = createBoxElement(tvState, box);
                    // Log if element creation failed immediately (might succeed on retry)
                    if (!box.element && tvState.screenWidth) {
                        console.warn(`Box element recreation potentially delayed for TV ${tvState.id} box ${box.id}`);
                    }
                 });
                 resizeTvScreen(tvState); // Resize after creating elements
                 checkAndAdjustBoxPositions(tvState.index); // Adjust positions after potential resize
                 updateTvGlow(tvState.index);
             });
             updateAllTvGlows();
        }
         function clearTvScreenBoxes(tvIndex) {
             const tvState = globalState.tvStates[tvIndex];
             if (tvState && tvState.elements && tvState.elements.screen) {
                 tvState.elements.screen.innerHTML = ''; // Clear screen content
                 tvState.boxes.forEach(box => box.element = null); // Nullify element references
             }
         }

        // --- Sizing and Positioning ---
        function resizeTvScreen(tvState) {
            if (!tvState.elements || !tvState.elements.screen) {
                 // If elements are missing, attempt to recreate them if the TV state exists
                 if (globalState && globalState.tvStates[tvState.index] && !tvState.elements) {
                     console.warn(`Elements missing for TV ${tvState.id}, attempting recreation.`);
                     recreateAllDomElements(); // Might be overkill, but ensures consistency
                 }
                 return;
            }
            const screenRect = tvState.elements.screen.getBoundingClientRect();

            if (screenRect.width <= 0 || screenRect.height <= 0) {
                if (!document.hidden) { // Only retry if visible
                    // Reduced frequency of resize retries
                    if (!tvState.resizeRetryTimeout) {
                         tvState.resizeRetryTimeout = setTimeout(() => {
                             tvState.resizeRetryTimeout = null;
                             resizeTvScreen(tvState);
                         }, 150);
                     }
                }
                return;
            }

            const oldWidth = tvState.screenWidth;
            const oldHeight = tvState.screenHeight;

            tvState.screenWidth = screenRect.width;
            tvState.screenHeight = screenRect.height;
            tvState.dynamicBoxHeight = Math.max(8, Math.floor(tvState.screenHeight * BASE_LOGO_HEIGHT_SCREEN_RATIO));
            tvState.dynamicBoxWidth = Math.floor(tvState.dynamicBoxHeight * BASE_BOX_ASPECT_RATIO);

            // Only resize boxes if dimensions actually changed significantly
            if (Math.abs(tvState.screenWidth - oldWidth) > 1 || Math.abs(tvState.screenHeight - oldHeight) > 1) {
                tvState.boxes.forEach(box => {
                    if (box.element) {
                        box.element.style.width = `${tvState.dynamicBoxWidth}px`;
                        box.element.style.height = `${tvState.dynamicBoxHeight}px`;
                    }
                    // Re-check and adjust position immediately after resize
                    box.x = Math.max(0, Math.min(box.x ?? tvState.screenWidth/2, tvState.screenWidth - tvState.dynamicBoxWidth));
                    box.y = Math.max(0, Math.min(box.y ?? tvState.screenHeight/2, tvState.screenHeight - tvState.dynamicBoxHeight));
                     if (box.element) {
                         box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                     }
                });
            }
        }

        function handleGlobalResize() {
            globalState.tvStates.forEach(tvState => {
                resizeTvScreen(tvState);
                // Adjustment now happens within resizeTvScreen if dimensions changed
            });
        }
        // This function ensures boxes are within bounds, useful after loading or significant resizes
        function checkAndAdjustBoxPositions(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
             if (!tvState || !tvState.screenWidth || !tvState.screenHeight || !tvState.dynamicBoxWidth || tvState.screenWidth <= 0 || tvState.screenHeight <= 0) {
                 // Delay adjustment if dimensions aren't ready
                 if (!document.hidden && !tvState.adjustRetryTimeout) {
                     tvState.adjustRetryTimeout = setTimeout(() => {
                         tvState.adjustRetryTimeout = null;
                         checkAndAdjustBoxPositions(tvIndex);
                     }, 150);
                 }
                 return;
             }
            tvState.boxes.forEach(box => {
                box.x = Math.max(0, Math.min(box.x ?? tvState.screenWidth/2, tvState.screenWidth - tvState.dynamicBoxWidth));
                box.y = Math.max(0, Math.min(box.y ?? tvState.screenHeight/2, tvState.screenHeight - tvState.dynamicBoxHeight));
                if (box.element) {
                    box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                } else {
                    // If element doesn't exist yet, try creating it again
                    box.element = createBoxElement(tvState, box);
                }
            });
        }

        // --- Update Loop ---
        function gameLoop(timestamp) {
            // Important: Use performance.now() for smooth animation timing
            if (document.hidden) { return; } // Don't run active loop if tab is hidden

            if (!lastTimestamp) { lastTimestamp = timestamp; return; }
            const deltaTime = Math.min(0.1, (timestamp - lastTimestamp) / 1000); // Limit delta time (seconds)
            lastTimestamp = timestamp; // Store current time for next frame calculation

            // Update game state for each TV
            globalState.tvStates.forEach((tvState, tvIndex) => {
                 if (!tvState.screenWidth || tvState.screenWidth <= 0) {
                    resizeTvScreen(tvState); // Try to resize if dimensions are missing/invalid
                 } else {
                    updateSingleTv(tvState, tvIndex, deltaTime, timestamp); // Pass performance timestamp for collision timers
                 }
             });

            // Update UI displays
            updateTotalHitsDisplay();
            updateTotalCornerHitsDisplay();
            updateAllTvGlows(); // Moved from inside updateSingleTv for efficiency
            checkMetaButtonVisibility();

            // Update modal buttons if open
            if (upgradeModal.classList.contains('show')) {
                if (selectedTvIndex !== -1) {
                    const tvState = globalState.tvStates[selectedTvIndex];
                    if (tvState) updateModalTvStats(tvState);
                    updateSelectedTvUpgradeButtons();
                } else {
                    modalTvStats.textContent = `Fragments: ${formatScore(globalState.systemFragments)}`;
                    updateMetaUpgradeButtonsIfVisible();
                    updateRebootPreviewIfVisible();
                }
            }

            // Periodic save (using Date.now() for interval check)
            const now = Date.now();
            if (now - lastSaveTime > 5000) { // Save every 5 seconds
                saveGame(); // This function now updates globalState.lastSaveTimestamp
                lastSaveTime = now;
            }
        }

        function updateSingleTv(tvState, tvIndex, deltaTime, timestamp) { // timestamp is performance.now()
             // Ensure dimensions are valid before proceeding
             if (!tvState.screenWidth || !tvState.screenHeight || !tvState.dynamicBoxWidth || !tvState.dynamicBoxHeight || tvState.screenWidth <= 0 || tvState.screenHeight <= 0) {
                 // resizeTvScreen(tvState); // Resize is handled in gameLoop now
                 return; // Skip update if dimensions are invalid
             }
            const screenWidth = tvState.screenWidth;
            const screenHeight = tvState.screenHeight;
            const effectiveBoxWidth = tvState.dynamicBoxWidth;
            const effectiveBoxHeight = tvState.dynamicBoxHeight;
            const currentSpeed = getCurrentTvSpeed(tvState);
            let cornerHitData = [];
            let boxCollisionsThisFrame = [];
            let wallHitData = [];

            tvState.boxes.forEach(box => {
                 if (!box.element) {
                     // Attempt to recreate element if missing (e.g., after load/resize issue)
                     box.element = createBoxElement(tvState, box);
                     if(!box.element) return; // Skip this box if element creation fails again
                     // Ensure position is set correctly if element was just created
                     box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                  }

                // Basic physics update
                if (isNaN(box.vx) || isNaN(box.vy)) return; // Skip if velocity is invalid
                let boxVX = box.vx; let boxVY = box.vy;
                // Adjust speed to match current upgrade level (smoothly)
                const speedMagnitude = Math.sqrt(boxVX**2 + boxVY**2);
                if (speedMagnitude > 0.01 && Math.abs(speedMagnitude - currentSpeed) > 0.1 * currentSpeed) {
                    const sf = currentSpeed/speedMagnitude;
                    boxVX*=(isNaN(sf)?1:sf); boxVY*=(isNaN(sf)?1:sf);
                } else if (speedMagnitude < 0.1*currentSpeed && currentSpeed > 0.1) { // Give a kick if too slow
                    const a = Math.random()*Math.PI*2;
                    boxVX=Math.cos(a)*currentSpeed*0.5; boxVY=Math.sin(a)*currentSpeed*0.5;
                }
                // Calculate movement based on delta time
                let deltaX = boxVX*deltaTime*60; // Scale movement by 60 for more intuitive speed values
                let deltaY = boxVY*deltaTime*60;
                // Clamp delta movement to avoid tunnelling through thin objects or extreme speeds
                deltaX = Math.max(-effectiveBoxWidth*0.8,Math.min(effectiveBoxWidth*0.8,deltaX));
                deltaY = Math.max(-effectiveBoxHeight*0.8,Math.min(effectiveBoxHeight*0.8,deltaY));
                box.x += deltaX;
                box.y += deltaY;

                // Wall collision detection & response
                let hitWall=false; let hitX=false, hitY=false; let hitSide = '';
                if (box.x <= 0 && boxVX < 0) { box.x = 0+Math.random()*0.1; boxVX = Math.abs(boxVX); hitWall=true; hitX=true; hitSide='left';}
                else if (box.x >= screenWidth-effectiveBoxWidth && boxVX > 0) { box.x = screenWidth-effectiveBoxWidth-Math.random()*0.1; boxVX = -Math.abs(boxVX); hitWall=true; hitX=true; hitSide='right';}
                if (box.y <= 0 && boxVY < 0) { box.y = 0+Math.random()*0.1; boxVY = Math.abs(boxVY); hitWall=true; hitY=true; hitSide='top';}
                else if (box.y >= screenHeight-effectiveBoxHeight && boxVY > 0) { box.y = screenHeight-effectiveBoxHeight-Math.random()*0.1; boxVY = -Math.abs(boxVY); hitWall=true; hitY=true; hitSide='bottom';}

                // Handle hits
                if (hitWall) {
                    if (box.element) box.element.style.backgroundColor = getRandomColor();
                    // Corner hit detection (more precise)
                    const cornerThreshold = Math.min(1.5, effectiveBoxWidth * 0.03, effectiveBoxHeight * 0.03); // Small threshold
                    const isNearLeft = box.x <= cornerThreshold;
                    const isNearRight = box.x >= screenWidth-effectiveBoxWidth-cornerThreshold;
                    const isNearTop = box.y <= cornerThreshold;
                    const isNearBottom = box.y >= screenHeight-effectiveBoxHeight-cornerThreshold;
                    const isCorner = (isNearLeft || isNearRight) && (isNearTop || isNearBottom);

                    if (isCorner && hitX && hitY) { // Requires hitting both walls near simultaneously
                        globalState.totalCornerHits++;
                        let cornerX = isNearLeft ? 0 : screenWidth;
                        let cornerY = isNearTop ? 0 : screenHeight;
                        const escapeFactor = 1.08;
                        if (isNearLeft) boxVX=Math.abs(boxVX)*escapeFactor; else boxVX=-Math.abs(boxVX)*escapeFactor;
                        if (isNearTop) boxVY=Math.abs(boxVY)*escapeFactor; else boxVY=-Math.abs(boxVY)*escapeFactor;
                        const baseBonus = tvState.cornerHitBaseBonus;
                        const percentBonus = globalState.lifetimeSessionHits * tvState.cornerHitPercentBonus;
                        const totalCornerBonus = (baseBonus + percentBonus);
                        cornerHitData.push({ x: cornerX, y: cornerY, boxId: box.id, bonusAmount: totalCornerBonus });
                    }
                    else { // Regular wall hit
                        const wallHitAmount = tvState.hitValue;
                        addTvHitScore(wallHitAmount); // Add score before effects
                        let popupX = box.x + effectiveBoxWidth / 2;
                        let popupY = box.y + effectiveBoxHeight / 2;
                        if (hitSide === 'left') popupX = effectiveBoxWidth * 0.5; else if (hitSide === 'right') popupX = screenWidth - effectiveBoxWidth * 0.5;
                        if (hitSide === 'top') popupY = effectiveBoxHeight * 0.5; else if (hitSide === 'bottom') popupY = screenHeight - effectiveBoxHeight * 0.5;
                        wallHitData.push({ x: popupX, y: popupY, amount: wallHitAmount });
                    }
                }
                // Update box velocity and clamp position
                box.vx = boxVX; box.vy = boxVY;
                box.x = Math.max(0, Math.min(box.x, screenWidth - effectiveBoxWidth));
                box.y = Math.max(0, Math.min(box.y, screenHeight - effectiveBoxHeight));
            });

            // Box-on-box collision (AABB)
            for (let i = 0; i < tvState.boxes.length; i++) {
                 if (!tvState.boxes[i].element) continue; // Skip if no element
                 for (let j = i + 1; j < tvState.boxes.length; j++) {
                    if (!tvState.boxes[j].element) continue; // Skip if no element

                    const b1 = tvState.boxes[i]; const b2 = tvState.boxes[j];
                    const b1CenterX = b1.x + effectiveBoxWidth / 2; const b1CenterY = b1.y + effectiveBoxHeight / 2;
                    const b2CenterX = b2.x + effectiveBoxWidth / 2; const b2CenterY = b2.y + effectiveBoxHeight / 2;
                    const dx = b2CenterX - b1CenterX; const dy = b2CenterY - b1CenterY;
                    const overlapX = effectiveBoxWidth - Math.abs(dx);
                    const overlapY = effectiveBoxHeight - Math.abs(dy);

                    if (overlapX > 0 && overlapY > 0) { // Collision
                        const collisionKey = getBoxCollisionKey(b1.id, b2.id);
                        const lastCollisionTime = boxCollisionTimers[collisionKey] || 0;
                        // Use performance.now() timestamp for collision cooldown
                        if (timestamp - lastCollisionTime < BOX_COLLISION_COOLDOWN_MS) continue;
                        boxCollisionTimers[collisionKey] = timestamp;

                        // Simplified separation and velocity exchange
                        if (overlapX < overlapY) { // Horizontal resolution
                            const separationAmount = overlapX * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dx < 0 ? -1 : 1;
                            b1.x -= separationAmount * sign; b2.x += separationAmount * sign;
                            const v1x = b1.vx; b1.vx = b2.vx * COLLISION_ENERGY_LOSS; b2.vx = v1x * COLLISION_ENERGY_LOSS;
                        } else { // Vertical resolution
                            const separationAmount = overlapY * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dy < 0 ? -1 : 1;
                            b1.y -= separationAmount * sign; b2.y += separationAmount * sign;
                            const v1y = b1.vy; b1.vy = b2.vy * COLLISION_ENERGY_LOSS; b2.vy = v1y * COLLISION_ENERGY_LOSS;
                        }
                        // Clamp positions after separation
                        b1.x = Math.max(0, Math.min(b1.x, screenWidth - effectiveBoxWidth)); b1.y = Math.max(0, Math.min(b1.y, screenHeight - effectiveBoxHeight));
                        b2.x = Math.max(0, Math.min(b2.x, screenWidth - effectiveBoxWidth)); b2.y = Math.max(0, Math.min(b2.y, screenHeight - effectiveBoxHeight));

                        boxCollisionsThisFrame.push({ b1Id: b1.id, b2Id: b2.id, x: b1CenterX + dx / 2, y: b1CenterY + dy / 2 });
                    }
                }
            }

            // --- Process Hit Effects for this Frame ---
            const synergy = globalState.synergyBonus;
            if (wallHitData.length > 0) { wallHitData.forEach(hit => { showFloatText(tvState, `+${formatScore(Math.ceil(hit.amount * synergy * DEV_SPEED_FACTOR))}`, hit.x, hit.y, 'wall'); }); }
            if (cornerHitData.length > 0) { cornerHitData.forEach(hit => { addTvHitScore(hit.bonusAmount); createSparkParticles(tvState, hit.x, hit.y); showFloatText(tvState, `CORNER HIT!\n+${formatScore(Math.ceil(hit.bonusAmount * synergy * DEV_SPEED_FACTOR))}`, tvState.screenWidth/2, tvState.screenHeight/2, 'corner'); }); }
            if (boxCollisionsThisFrame.length > 0) {
                let collisionValue = tvState.boxCollisionValue;
                let totalCollisionBonus = boxCollisionsThisFrame.length * collisionValue;
                addTvHitScore(totalCollisionBonus);
                boxCollisionsThisFrame.forEach(hit => {
                    showFloatText(tvState, `+${formatScore(Math.ceil(collisionValue * synergy * DEV_SPEED_FACTOR))}`, hit.x, hit.y, 'collision');
                });
            }

            // --- Update Element Positions ---
            tvState.boxes.forEach(box => {
                if (box.element) {
                     box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                }
            });
        }

        // --- Scoring & Stats ---
        function addTvHitScore(amount) { if (amount <= 0 || isNaN(amount)) return; const amountWithSynergy = amount * globalState.synergyBonus; const effectiveGain = Math.ceil(amountWithSynergy * DEV_SPEED_FACTOR); if (effectiveGain <= 0) return; globalState.totalSessionHits += effectiveGain; globalState.lifetimeSessionHits += effectiveGain; }
        function updateModalTvStats(tvState) { if (!modalTvStats || !tvState) return; const currentMaxBoxes = globalState.maxBoxesPerTv; modalTvStats.textContent = `TV #${tvState.id} | Logos: ${tvState.boxes.length}/${currentMaxBoxes}`; }
        function updateTotalHitsDisplay() { if (totalHitsDisplay) { totalHitsDisplay.textContent = `Hits: ${formatScore(globalState.totalSessionHits)}`; } }
        function updateTotalCornerHitsDisplay() { if (totalCornerHitsDisplay) { totalCornerHitsDisplay.textContent = `Corners: ${formatScore(globalState.totalCornerHits)}`; } }

        // --- Effects & Feedback ---
        function createSparkParticles(tvState, cornerX, cornerY) { if (!tvState.elements || !tvState.elements.screen) return; const screenElement = tvState.elements.screen; const particleCount = 12; const particleLifespan = 650; const particleSpread = tvState.screenWidth * 0.18; for (let i = 0; i < particleCount; i++) { const p = document.createElement('div'); p.classList.add('spark-particle'); p.style.left = `${cornerX}px`; p.style.top = `${cornerY}px`; screenElement.appendChild(p); const ang = Math.random()*Math.PI*2; const dist = Math.random()*particleSpread; let dX=Math.cos(ang); let dY=Math.sin(ang); if(cornerX<tvState.screenWidth/2) dX=Math.abs(dX); else dX=-Math.abs(dX); if(cornerY<tvState.screenHeight/2) dY=Math.abs(dY); else dY=-Math.abs(dY); const tX=dX*dist; const tY=dY*dist; requestAnimationFrame(()=>{p.style.transform=`translate(${tX}px, ${tY}px) scale(0.5)`; p.style.opacity=0; }); setTimeout(()=>{ p.remove(); }, particleLifespan); } }
        function showNotification(message) { if (!notificationElement) return; notificationElement.textContent = message; notificationElement.className = 'show'; if (notificationElement.timer) clearTimeout(notificationElement.timer); notificationElement.timer = setTimeout(() => { notificationElement.className = ''; notificationElement.timer = null; }, 2800); } // Slightly longer duration
        function showFloatText(tvState, text, x, y, type = 'corner' | 'collision' | 'wall') { if (!tvState.elements || !tvState.elements.screen) return; const screenElement = tvState.elements.screen; const textElement = document.createElement('div'); textElement.classList.add('float-text'); let textClass = ''; let duration = 1000; switch(type) { case 'corner': textClass = 'corner-hit-text'; duration = 1300; break; case 'collision': textClass = 'collision-text'; duration = 900; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break; case 'wall': textClass = 'wall-hit-text'; duration = 800; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break; default: return; } textElement.classList.add(textClass); textElement.textContent = text; screenElement.appendChild(textElement); setTimeout(() => { if (textElement.parentNode) textElement.remove(); }, duration); }

        // --- Glow Logic (Controls Power Light) ---
        function checkTvAffordability(tvState) {
             if (!tvState) return false;
             const currentHits = globalState.totalSessionHits;
             for (const upgrade of tvUpgrades) {
                 const level = upgrade.getLevel(tvState);
                 let maxLevel;
                 if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv;
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(tvState);
                 else maxLevel = upgrade.maxLevel;
                 const isMaxLevel = (maxLevel !== undefined && level >= maxLevel);
                 if (isMaxLevel) continue;

                 let canPurchaseCheck = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, level) : true;
                 if (!canPurchaseCheck) continue;

                 // Check cost of ONLY the next level for glow affordability
                 const cost = calculateCost(upgrade.baseCost, level, upgrade.costFactor, tvState.index);
                 if (currentHits >= cost) {
                     return true; // Found at least one affordable single upgrade
                 }
             }
             return false; // No affordable single upgrades found
        }
        function updateTvGlow(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
            if (tvState && tvState.elements && tvState.elements.frame) {
                const frame = tvState.elements.frame;
                const canAfford = checkTvAffordability(tvState);
                frame.classList.toggle('can-upgrade-glow', canAfford);
            }
        }
        function updateAllTvGlows() {
             globalState.tvStates.forEach((tv, index) => updateTvGlow(index));
        }

        // --- Upgrade Definitions ---
        const tvUpgrades = [
             { id: 'hitValue', name: 'Hit Value', baseCost: 10, costFactor: 1.45, getLevel: (tv) => tv.upgrades.hitValue, applyEffect: (tv) => { tv.upgrades.hitValue++; }, getDescription: (tv, l) => `Lv ${l}: +Hit Value` },
             { id: 'speed', name: 'Speed', baseCost: 40, costFactor: 1.65, maxLevel: 25, getLevel: (tv) => tv.upgrades.speed, applyEffect: (tv) => { tv.upgrades.speed++; }, getDescription: (tv, l, maxed) => maxed ? `Max Speed (Lv ${l})` : `Lv ${l}: +Speed` },
             { id: 'cornerBonusFlat', name: 'Corner Flat Bonus', baseCost: 60, costFactor: 1.75, getLevel: (tv) => tv.upgrades.cornerBonusFlat, applyEffect: (tv) => { tv.upgrades.cornerBonusFlat++; }, getDescription: (tv, l) => `Lv ${l}: +Corner Bonus` },
             { id: 'cornerBonusPercent', name: 'Corner % Bonus', baseCost: 800, costFactor: 2.3, getLevel: (tv) => tv.upgrades.cornerBonusPercent, applyEffect: (tv) => { tv.upgrades.cornerBonusPercent++; }, getDescription: (tv, l) => `Lv ${l}: +${(deriveTvCornerPercentBonus(tv,l+1)*100).toFixed(4)}% CB<br>(Global Hits)` },
             { id: 'multiBox', name: 'Add Logo', baseCost: 300, costFactor: 3.5,
                getMaxLevel: (tv) => globalState.maxBoxesPerTv, getLevel: (tv) => tv.boxes.length,
                applyEffect: (tv, tvIndex, count = 1) => { let added = 0; for (let i = 0; i < count; i++) { if(addBoxToTv(tvIndex)) added++; else break; } if (added < count && count > 1 && tv.boxes.length >= globalState.maxBoxesPerTv) showNotification("Max logos reached!"); return added > 0; },
                canPurchase: (tv, levelToCheck) => (levelToCheck ?? tv.boxes.length) < globalState.maxBoxesPerTv, // Check against global max
                getDescription: (tv, l, maxed) => maxed ? `Max Logos (${tv.boxes.length})` : `Add Logo (${l+1}/${globalState.maxBoxesPerTv})` },
             { id: 'boxCollisionValue', name: 'Collision Hits', baseCost: 1500, costFactor: 1.95, getLevel: (tv) => tv.upgrades.boxCollisionValue, applyEffect: (tv) => { tv.upgrades.boxCollisionValue++; }, getDescription: (tv, l) => `Lv ${l}: +Collision Hits` },
        ];
        const metaUpgrades = [
             { id: 'metaFragmentGain', name: 'Fragment Gain', baseCost: 3, costFactor: 2.2, getLevel: () => globalState.metaLevels.fragmentGain, applyEffect: () => { globalState.metaLevels.fragmentGain++; }, getDescription: (gs, l, c) => `Lv ${l}: +${((deriveMetaFragmentMult(l+1)-1)*100).toFixed(0)}% Fragments<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaAddTv', name: 'Add New TV', baseCost: 5, costFactor: 4.5, getLevel: () => globalState.tvStates.length, applyEffect: () => { addTv(); }, canPurchase: () => true, // Always purchasable
               getDescription: (gs, l, c) => `Add TV #${l+1}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaBaseSpeed', name: 'Base Speed', baseCost: 10, costFactor: 2.8, maxLevel: 15, getLevel: () => globalState.metaLevels.baseSpeed, applyEffect: () => { globalState.metaLevels.baseSpeed++; updateAllTvsPostMeta(); }, getDescription: (gs, l, c, maxed) => maxed ? `Max Base Speed (Lv ${l})`:`Lv ${l}: +Speed All TVs<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaBaseMaxBoxes', name: 'Global Capacity', baseCost: 15, costFactor: 3.5, maxLevel: MAX_BOXES_PER_TV,
                getLevel: () => globalState.metaLevels.baseMaxBoxes, applyEffect: () => { globalState.metaLevels.baseMaxBoxes++; updateAllTvsPostMeta(); updateMetaUpgradeButtonsIfVisible(); updateSelectedTvUpgradeButtons(); }, // Update TV buttons if logo limit changed
                getDescription: (gs, l, c, maxed) => maxed ? `Max Global Cap (${gs.maxBoxesPerTv})` : `Lv ${l}: Global Max Logos: ${deriveMetaBaseMaxBoxes(l+1)}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaTvSynergyBonus', name: 'TV Synergy', baseCost: 50, costFactor: 2.5, getLevel: () => globalState.metaLevels.tvSynergyBonus, applyEffect: () => { globalState.metaLevels.tvSynergyBonus++; recalculateGlobalSynergy(); updateMetaUpgradeButtonsIfVisible(); },
               getDescription: (gs, l, c) => { const nextLevel = l + 1; const nextPerTvBonus = deriveSynergyBonusPerTv(nextLevel); const currentNumTvs = gs.tvStates.length; const nextTotalBonus = 1.0 + currentNumTvs * nextPerTvBonus; return `Lv ${l}: All Hits x${globalState.synergyBonus.toFixed(3)}<br>(Next: +${(nextPerTvBonus*100).toFixed(2)}% per TV)<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>`; } },
        ];

        // --- Upgrade Calculation Functions ---
        function deriveTvHitValue(tvState, level) { return Math.max(1, Math.ceil(1 + level * 0.75)); }
        function deriveTvSpeedFactor(tvState, level) { return Math.min(3.0, (1 + level * 0.04) * tvState.baseSpeedFactorMeta); }
        function deriveTvCornerFlatBonus(tvState, level) { return Math.max(0, Math.floor(1000 + level * 4 + Math.pow(level, 1.45))); }
        function deriveTvCornerPercentBonus(tvState, level) { return level * 0.00001; }
        function deriveTvCollisionBonus(tvState, level) { return Math.max(0, Math.floor(2 + level * 0.5 + Math.pow(level, 1.2))); }
        function getCurrentTvSpeed(tvState) { return BASE_SPEED_CONSTANT * deriveTvSpeedFactor(tvState, tvState.upgrades.speed); }
        function deriveMetaFragmentMult(level) { return 1 + level * 0.07; }
        function deriveMetaBaseSpeedFactor(level) { return 1 + level * 0.03; }
        function deriveMetaBaseMaxBoxes(level) { return 2 + level; } // Starts at 2 logos (+1 per level)
        function deriveSynergyBonusPerTv(level) { return level > 0 ? (level * 0.005) : 0; }
        function deriveSynergyBonus(level) { const perTvBonus = deriveSynergyBonusPerTv(level); const numTvs = globalState?.tvStates?.length ?? 0; return 1.0 + (numTvs * perTvBonus); }

        // --- Apply Upgrades ---
        function recalculateDerivedTvState(tvState) { tvState.hitValue = deriveTvHitValue(tvState, tvState.upgrades.hitValue); tvState.cornerHitBaseBonus = deriveTvCornerFlatBonus(tvState, tvState.upgrades.cornerBonusFlat); tvState.cornerHitPercentBonus = deriveTvCornerPercentBonus(tvState, tvState.upgrades.cornerBonusPercent); tvState.boxCollisionValue = deriveTvCollisionBonus(tvState, tvState.upgrades.boxCollisionValue); }
        function recalculateGlobalSynergy() { globalState.synergyBonus = deriveSynergyBonus(globalState.metaLevels.tvSynergyBonus); }
        function applyMetaUpgradesToTv(tvState) { tvState.baseSpeedFactorMeta = deriveMetaBaseSpeedFactor(globalState.metaLevels.baseSpeed); recalculateDerivedTvState(tvState); resizeTvScreen(tvState); /* Resize might depend on derived state */ }
        function updateAllTvsPostMeta() { globalState.maxBoxesPerTv = deriveMetaBaseMaxBoxes(globalState.metaLevels.baseMaxBoxes); globalState.tvStates.forEach(tv => { applyMetaUpgradesToTv(tv); checkAndAdjustBoxPositions(tv.index); }); recalculateGlobalSynergy(); updateAllTvGlows(); }

        // --- Upgrade UI & Modal Logic ---
        function openUpgradeModal(tvIndex = -1) {
            selectedTvIndex = tvIndex; modalUpgradesContainer.innerHTML = ''; modalRebootContainer.innerHTML = ''; modalBuyAmountContainer.innerHTML = ''; // Clear previous content

            if (tvIndex !== -1) { // TV Specific Modal
                const tvState = globalState.tvStates[tvIndex]; if (!tvState) return; // Safety check
                modalTitle.textContent = `TV #${tvState.id} Upgrades`;
                updateModalTvStats(tvState); // Show TV logo count
                renderBuyAmountButtons(); // Show buy amount selectors
                renderUpgradeSection(tvUpgrades, modalUpgradesContainer, 'hit', tvIndex); // Render TV upgrades
            } else { // Meta Modal
                modalTitle.textContent = 'Meta Upgrades & Reboot';
                modalTvStats.textContent = `Fragments: ${formatScore(globalState.systemFragments)}`; // Show Fragment count
                renderUpgradeSection(metaUpgrades, modalUpgradesContainer, 'meta'); // Render Meta upgrades
                // Add Reboot section if applicable
                const potentialGain = calculateFragmentGain(globalState.lifetimeSessionHits);
                if (potentialGain > 0 || globalState.hasRebootedOnce) { // Show if potential gain > 0 OR already rebooted once
                    const rebootTemplate = document.getElementById('reboot-section-template');
                    if (rebootTemplate) {
                        const clonedReboot = rebootTemplate.firstElementChild.cloneNode(true);
                        const rebootBtn = clonedReboot.querySelector('#reboot-button');
                        if (rebootBtn) { rebootBtn.onclick = executeReboot; }
                        modalRebootContainer.appendChild(clonedReboot);
                        updateRebootPreviewIfVisible(); // Set initial state
                    } else { console.error("Reboot template not found!"); }
                }
            }
            upgradeModal.classList.add('show'); // Display the modal
        }
        function closeUpgradeModal() { upgradeModal.classList.remove('show'); selectedTvIndex = -1; updateAllTvGlows(); /* Update glows when closing */ }
        function renderBuyAmountButtons() {
            modalBuyAmountContainer.innerHTML = ''; const amounts = [1, 10, 100, 'max'];
            amounts.forEach(amount => {
                const btn = document.createElement('button'); btn.classList.add('buy-amount-button'); btn.textContent = `${amount === 'max' ? 'Max' : 'x'+amount}`; btn.dataset.amount = amount;
                if (selectedBuyAmount === amount || (selectedBuyAmount === Infinity && amount === 'max')) { btn.classList.add('active'); } // Highlight current selection
                btn.onclick = () => setBuyAmount(amount); modalBuyAmountContainer.appendChild(btn);
            });
        }
        function setBuyAmount(amount) {
            selectedBuyAmount = (amount === 'max') ? Infinity : parseInt(amount); // Use Infinity for 'max'
            globalState.selectedBuyAmount = (amount === 'max') ? 'max' : selectedBuyAmount; // Save preference
            const buttons = modalBuyAmountContainer.querySelectorAll('.buy-amount-button');
            buttons.forEach(btn => { const btnAmount = btn.dataset.amount; const isActive = (selectedBuyAmount === Infinity && btnAmount === 'max') || (selectedBuyAmount === parseInt(btnAmount)); btn.classList.toggle('active', isActive); });
            updateSelectedTvUpgradeButtons(); // Update TV upgrade button costs/levels immediately
        }

        function calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex) {
            const amountToTry = selectedBuyAmount;
            const currentLevel = upgrade.getLevel(tvState);
            let totalCost = 0; let levelsBought = 0; let maxLevelReached = false;
            let nextLevelCost = 0; // Cost of the very next level

            // Determine max level for this upgrade
            let maxLevel;
            if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv;
            else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(tvState);
            else maxLevel = upgrade.maxLevel;

            const isCurrentlyMaxed = (maxLevel !== undefined && currentLevel >= maxLevel) || !(typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, currentLevel) : true);

            if (isCurrentlyMaxed) {
                return { levels: 0, totalCost: 0, affordable: false, isMaxLevel: true, nextLevelCost: 0 };
            }

            // Calculate cost of the single next level regardless of affordability
            nextLevelCost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor, tvIndex);

            // Calculate for bulk buy
            const maxIterations = (amountToTry === Infinity) ? MAX_BULK_BUY_CHECK : amountToTry;
            const flooredScore = Math.floor(currentScore); // Use floored score for comparisons

            for (let i = 0; i < maxIterations; i++) {
                const levelToCheck = currentLevel + levelsBought; // Check next level from current state

                // Re-check max level condition inside loop
                if (maxLevel !== undefined && levelToCheck >= maxLevel) { maxLevelReached = true; break; }
                // Re-check canPurchase condition inside loop
                if (!(typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, levelToCheck) : true)) { maxLevelReached = true; break; }

                const costForThisLevel = calculateCost(upgrade.baseCost, levelToCheck, upgrade.costFactor, tvIndex);
                if (flooredScore >= totalCost + costForThisLevel) { // Compare against affordable total
                    totalCost += costForThisLevel;
                    levelsBought++;
                } else {
                    // Can't afford the next level in the bulk buy
                    break;
                }
            }

            const affordable = levelsBought > 0; // Affordable only if >0 levels bought

            return {
                levels: levelsBought,
                totalCost: totalCost, // Cost for the 'levelsBought' levels
                affordable: affordable,
                isMaxLevel: isCurrentlyMaxed || (maxLevelReached && levelsBought === 0), // Is maxed check refined
                nextLevelCost: nextLevelCost // Cost of the single next level from current
            };
        }

        // Renders the initial set of upgrade buttons
        function renderUpgradeSection(upgrades, container, currencyType, tvIndex = -1) {
             if (!container) return; container.innerHTML = ''; // Clear previous buttons
             const isTvModal = currencyType === 'hit' && tvIndex !== -1;
             const tvState = isTvModal ? globalState.tvStates[tvIndex] : null;
             const stateForLevel = tvState ?? globalState;
             const currentScore = currencyType === 'hit' ? globalState.totalSessionHits : globalState.systemFragments;

             upgrades.forEach(upgrade => {
                 const currentLevel = upgrade.getLevel(stateForLevel);
                 let bulkInfo = { levels: 1, totalCost: 0, affordable: false, isMaxLevel: false, nextLevelCost: 0 };
                 let descriptionText = ''; let currencyClass = currencyType;
                 let costToShow = 0;
                 let levelText = '';
                 let isCurrentlyMaxed = false; // Default to not maxed

                 // Check if currently maxed out
                 let maxLevelCheck;
                 if (upgrade.id === 'multiBox' && tvState) maxLevelCheck = globalState.maxBoxesPerTv; // Use global for multiBox
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevelCheck = upgrade.getMaxLevel(stateForLevel);
                 else maxLevelCheck = upgrade.maxLevel;

                 isCurrentlyMaxed = (maxLevelCheck !== undefined && currentLevel >= maxLevelCheck);
                 if (!isCurrentlyMaxed && typeof upgrade.canPurchase === 'function') {
                     isCurrentlyMaxed = !upgrade.canPurchase(stateForLevel, currentLevel);
                 }


                 if (isTvModal && tvState) { // TV Upgrades
                     bulkInfo = calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex);
                     isCurrentlyMaxed = bulkInfo.isMaxLevel; // Use result from calculation
                     descriptionText = upgrade.getDescription(tvState, currentLevel, isCurrentlyMaxed);
                     if (!isCurrentlyMaxed) {
                         if (bulkInfo.affordable && bulkInfo.levels > 0) { // Ensure levels > 0 are affordable
                             costToShow = bulkInfo.totalCost;
                             if (bulkInfo.levels > 1) levelText = ` (x${bulkInfo.levels})`;
                         } else {
                             costToShow = bulkInfo.nextLevelCost; // Show cost of next single level if bulk is unaffordable
                         }
                     }
                 } else { // Meta Upgrades
                     const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor);
                     costToShow = cost; // Meta always shows cost of next level
                     bulkInfo.affordable = currentScore >= cost && !isCurrentlyMaxed;
                     bulkInfo.isMaxLevel = isCurrentlyMaxed;
                     descriptionText = upgrade.getDescription(globalState, currentLevel, cost, bulkInfo.isMaxLevel);
                 }

                 // Create Button Element
                 const btn = document.createElement('button');
                 btn.classList.add('upgrade-button');
                 btn.dataset.upgradeId = upgrade.id;
                 btn.dataset.currencyType = currencyType;
                 if (tvIndex >= 0) btn.dataset.tvIndex = tvIndex;

                 // Set Button Content
                 btn.innerHTML = `<div class="upgrade-description">${descriptionText}</div>`;
                 if (!isCurrentlyMaxed && !(currencyType === 'meta')) { // Add cost div only if not maxed AND not meta
                     btn.innerHTML += `<div class="upgrade-cost ${currencyClass}">Cost: ${formatScore(costToShow)}${levelText}</div>`;
                 } else if (isCurrentlyMaxed && !(currencyType === 'meta')) {
                     // Optionally add a 'Maxed' text instead of cost
                     // btn.innerHTML += `<div class="upgrade-cost ${currencyClass}">Maxed</div>`;
                 }

                 btn.disabled = isCurrentlyMaxed || !bulkInfo.affordable; // Disable if maxed OR cannot afford
                 btn.onclick = () => buyUpgrade(upgrade.id, currencyType, tvIndex);
                 container.appendChild(btn);
             });
        }


        // Updates existing buttons in a section
        function updateUpgradeButtonsInSection(upgrades, container, currencyType, tvIndex = -1) {
            if (!container) return;
            const isTvModal = currencyType === 'hit' && tvIndex !== -1;
            const tvState = isTvModal ? globalState.tvStates[tvIndex] : null;
            const stateForLevel = tvState ?? globalState;
            const currentScore = currencyType === 'hit' ? globalState.totalSessionHits : globalState.systemFragments;

            upgrades.forEach(upgrade => {
                const btn = container.querySelector(`[data-upgrade-id="${upgrade.id}"]`);
                if (btn) {
                    const currentLevel = upgrade.getLevel(stateForLevel);
                    let bulkInfo = { levels: 1, totalCost: 0, affordable: false, isMaxLevel: false, nextLevelCost: 0 };
                    let descriptionText = ''; let currencyClass = currencyType;
                    let costToShow = 0;
                    let levelText = '';
                    let isCurrentlyMaxed = false;

                    // Check max level condition
                    let maxLevelCheck;
                    if (upgrade.id === 'multiBox' && tvState) maxLevelCheck = globalState.maxBoxesPerTv; // Use global for multiBox
                    else if (typeof upgrade.getMaxLevel === 'function') maxLevelCheck = upgrade.getMaxLevel(stateForLevel);
                    else maxLevelCheck = upgrade.maxLevel;

                    isCurrentlyMaxed = (maxLevelCheck !== undefined && currentLevel >= maxLevelCheck);
                     if (!isCurrentlyMaxed && typeof upgrade.canPurchase === 'function') {
                        isCurrentlyMaxed = !upgrade.canPurchase(stateForLevel, currentLevel);
                     }


                    const descDiv = btn.querySelector('.upgrade-description');
                    let costDiv = btn.querySelector('.upgrade-cost');

                    // Calculate affordability and update content
                    if (isTvModal && tvState) { // TV upgrade
                        bulkInfo = calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex);
                        isCurrentlyMaxed = bulkInfo.isMaxLevel;
                        descriptionText = upgrade.getDescription(tvState, currentLevel, isCurrentlyMaxed);
                        if (descDiv) descDiv.innerHTML = descriptionText;

                        if (!isCurrentlyMaxed) {
                            if (bulkInfo.affordable && bulkInfo.levels > 0) {
                                costToShow = bulkInfo.totalCost;
                                if (bulkInfo.levels > 1) levelText = ` (x${bulkInfo.levels})`;
                            } else {
                                costToShow = bulkInfo.nextLevelCost;
                            }
                            if (!costDiv) {
                                costDiv = document.createElement('div');
                                costDiv.classList.add('upgrade-cost', currencyClass);
                                btn.appendChild(costDiv);
                            }
                            costDiv.innerHTML = `Cost: ${formatScore(costToShow)}${levelText}`;
                            costDiv.style.display = '';
                        } else {
                            if (costDiv) costDiv.style.display = 'none';
                        }

                    } else { // Meta upgrade
                        const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor);
                        costToShow = cost;
                        bulkInfo.affordable = currentScore >= cost && !isCurrentlyMaxed;
                        bulkInfo.isMaxLevel = isCurrentlyMaxed;
                        descriptionText = upgrade.getDescription(globalState, currentLevel, cost, bulkInfo.isMaxLevel);
                        if (descDiv) descDiv.innerHTML = descriptionText;
                        if(costDiv && currencyType === 'meta') costDiv.style.display = 'none';
                    }

                    // Update button disabled state
                    btn.disabled = isCurrentlyMaxed || !bulkInfo.affordable;
                }
            });
        }


        function buyUpgrade(id, currencyType, tvIndex = -1) {
            const upgrades = currencyType === 'hit' ? tvUpgrades : metaUpgrades;
            const upgrade = upgrades.find(u => u.id === id); if (!upgrade) return;

            const isTvUpgrade = currencyType === 'hit' && tvIndex !== -1;
            const amountToTry = isTvUpgrade ? selectedBuyAmount : 1; // Buy 1 for meta

            const stateToModify = isTvUpgrade ? globalState.tvStates[tvIndex] : globalState;
            if (!stateToModify) { console.error("Invalid state for upgrade:", id, currencyType, tvIndex); return; }

            const scoreRef = currencyType === 'hit' ? 'totalSessionHits' : 'systemFragments';
            const currentScore = globalState[scoreRef];

            let currentLevel = upgrade.getLevel(stateToModify);
            let totalCost = 0;
            let levelsToBuy = 0;

            // Calculate how many levels can actually be bought
            const maxIterations = (amountToTry === Infinity) ? MAX_BULK_BUY_CHECK : amountToTry;
            const flooredScore = Math.floor(currentScore); // Use floored score for comparisons

            for (let i = 0; i < maxIterations; i++) {
                const levelToCheck = currentLevel + levelsToBuy;

                // Check max level
                let maxLevel;
                 if (upgrade.id === 'multiBox' && isTvUpgrade) maxLevel = globalState.maxBoxesPerTv; // Use global for multiBox
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(stateToModify);
                 else maxLevel = upgrade.maxLevel;
                if (maxLevel !== undefined && levelToCheck >= maxLevel) break;

                // Check purchase condition
                if (!(typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(stateToModify, levelToCheck) : true)) break;

                const costForThisLevel = calculateCost(upgrade.baseCost, levelToCheck, upgrade.costFactor, tvIndex);

                if (flooredScore >= totalCost + costForThisLevel) {
                    totalCost += costForThisLevel;
                    levelsToBuy++;
                } else {
                    break;
                }
            }


            // Execute purchase if affordable
            if (levelsToBuy > 0) {
                globalState[scoreRef] -= totalCost;

                // Apply the effect(s)
                if (isTvUpgrade) {
                    if (upgrade.id === 'multiBox') {
                        upgrade.applyEffect(stateToModify, tvIndex, levelsToBuy); // Special case for adding multiple boxes
                    } else {
                         for(let k=0; k<levelsToBuy; k++) {
                             upgrade.applyEffect(stateToModify, tvIndex);
                         }
                    }
                    recalculateDerivedTvState(stateToModify);
                    updateModalTvStats(stateToModify);
                    updateSelectedTvUpgradeButtons();
                    updateTvGlow(tvIndex);
                } else { // Meta Upgrade purchase
                     upgrade.applyEffect(stateToModify, tvIndex); // Apply effect once (levelsToBuy is always 1 here)
                     if (upgrade.id === 'metaTvSynergyBonus' || upgrade.id === 'metaAddTv') recalculateGlobalSynergy();
                     if (upgrade.id === 'metaBaseMaxBoxes' || upgrade.id === 'metaBaseSpeed') updateAllTvsPostMeta();
                     if (upgrade.id === 'metaAddTv') checkMetaButtonVisibility();
                     if (upgrade.id === 'metaBaseMaxBoxes') {
                         // If max boxes changed, we might need to update TV upgrade buttons if the modal is open
                         updateSelectedTvUpgradeButtons();
                     }
                     modalTvStats.textContent = `Fragments: ${formatScore(globalState.systemFragments)}`;
                     updateMetaUpgradeButtonsIfVisible();
                     updateRebootPreviewIfVisible();
                     updateAllTvGlows();
                }

                updateTotalHitsDisplay();
                // Save game immediately after purchase
                saveGame();
            } else {
                 const nextCost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor, tvIndex);
                 console.log(`Cannot afford ${amountToTry === Infinity ? 1 : amountToTry} level(s) of ${id}. Need ${formatScore(nextCost)}, have ${formatScore(currentScore)}`);
                 // Optionally flash the button red or provide other feedback
            }
        }

        // --- Button Updates ---
        function updateSelectedTvUpgradeButtons() { if (selectedTvIndex !== -1 && upgradeModal.classList.contains('show')) { updateUpgradeButtonsInSection(tvUpgrades, modalUpgradesContainer, 'hit', selectedTvIndex); } }
        function updateMetaUpgradeButtonsIfVisible() { if (selectedTvIndex === -1 && upgradeModal.classList.contains('show')) { updateUpgradeButtonsInSection(metaUpgrades, modalUpgradesContainer, 'meta'); } }

        // --- Reboot Logic ---
        function canCurrentlyReboot() { return globalState.systemFragments > 0 || globalState.hasRebootedOnce || calculateFragmentGain(globalState.lifetimeSessionHits) > 0; }
        function checkMetaButtonVisibility() { metaMenuButton.classList.toggle('show', canCurrentlyReboot()); }
        function updateRebootPreviewIfVisible() { if (selectedTvIndex !== -1 || !upgradeModal.classList.contains('show')) return; const rebootSection = modalRebootContainer.querySelector('#reboot-section'); if (!rebootSection) return; const rebootGainPreview = rebootSection.querySelector('#reboot-gain-preview'); const rebootButton = rebootSection.querySelector('#reboot-button'); if (!rebootGainPreview || !rebootButton) return; const gain = calculateFragmentGain(globalState.lifetimeSessionHits); rebootGainPreview.textContent = `Gain ~${formatScore(gain)} Fragments (from ${formatScore(globalState.lifetimeSessionHits)} total Hits)`; rebootButton.disabled = gain <= 0; }
        function calculateFragmentGain(totalLifetimeHits) { if (totalLifetimeHits < 5000) return 0; const metaMultiplier = deriveMetaFragmentMult(globalState.metaLevels.fragmentGain); const baseGain = Math.pow(totalLifetimeHits / 5000, 0.45) * 1.5; const logBonus = Math.log10(totalLifetimeHits / 5000 + 1) * 0.5; const gain = Math.floor((baseGain + logBonus) * metaMultiplier); return Math.max(0, gain); }
        function executeReboot() {
             const fragmentsGained = calculateFragmentGain(globalState.lifetimeSessionHits); if (fragmentsGained <= 0) { showNotification("Not enough lifetime Hits for fragments"); return; } if (!confirm(`Reboot: Gain ${formatScore(fragmentsGained)} Fragments?\n\nResets session Hits, Corner Hits & TV Upgrades.\nKeeps Fragments, Meta Upgrades & Unlocked TVs.`)) { return; } closeUpgradeModal(); showNotification(`Rebooted! +${formatScore(fragmentsGained)} Fragments`); globalState.systemFragments += fragmentsGained; globalState.hasRebootedOnce = true; globalState.totalSessionHits = 0; globalState.lifetimeSessionHits = 0; // Reset lifetime hits used for gain calculation
             globalState.totalCornerHits = 0;
             boxCollisionTimers = {};
             globalState.tvStates.forEach((tvState, index) => { Object.keys(tvState.upgrades).forEach(key => { tvState.upgrades[key] = 0; }); // Reset upgrades
                 clearTvScreenBoxes(index); // Remove old boxes visually and logically
                 tvState.boxes = []; // Ensure boxes array is empty
                 tvState.nextBoxId = 0; // Reset box ID counter for the TV
                 recalculateDerivedTvState(tvState); // Reset derived stats
                 applyMetaUpgradesToTv(tvState); // Reapply meta effects
                 addBoxToTv(index); // Add the initial box back
                 resizeTvScreen(tvState); // Ensure screen size is correct
                 checkAndAdjustBoxPositions(index); // Ensure box is positioned correctly
            });
             recalculateGlobalSynergy(); updateTotalHitsDisplay(); updateTotalCornerHitsDisplay();
             updateAllTvGlows(); checkMetaButtonVisibility(); saveGame();
         }

        // --- Saving and Loading ---
        function saveGame() {
            try {
                // Don't save if tab is hidden AND hasn't saved recently (prevents excessive saving on brief hide/show)
                const now = Date.now();
                 if (document.hidden && (now - lastSaveTime < 4000)) {
                     return;
                 }
                 if (!globalState) {
                     console.warn("Attempted to save with null globalState.");
                     return;
                 }

                // *** Add current timestamp before saving ***
                globalState.lastSaveTimestamp = now;
                lastSaveTime = now; // Update last save time tracker

                const amountToSave = (selectedBuyAmount === Infinity) ? 'max' : selectedBuyAmount;
                const stateToSave = JSON.parse(JSON.stringify({...globalState, selectedBuyAmount: amountToSave}, (key, value) => {
                    if (key === 'elements' || key === 'element' || key === 'resizeRetryTimeout' || key === 'adjustRetryTimeout') return undefined; // Exclude transient/DOM properties
                     if (['x', 'y', 'vx', 'vy'].includes(key)) {
                         return (typeof value === 'number' && !isNaN(value)) ? value : 0;
                     }
                    return value;
                }));
                localStorage.setItem(SAVE_KEY, JSON.stringify(stateToSave));
                // console.log("Game Saved at", new Date(globalState.lastSaveTimestamp).toLocaleTimeString()); // Optional debug log

            } catch (e) {
                console.error("Save Error:", e);
                showNotification("Save Error!");
            }
        }
        function loadGame() {
            const savedData = localStorage.getItem(SAVE_KEY);
            let needsInitialization = true;
            let offlineGains = 0; // Track offline gains separately

            if (savedData) {
                try {
                    const loadedState = JSON.parse(savedData);
                    // Basic validation
                    if (typeof loadedState.systemFragments === 'number' && Array.isArray(loadedState.tvStates) && loadedState.metaLevels) {
                        globalState = createDefaultGlobalState(); // Start with defaults
                        globalState = deepMerge(globalState, loadedState); // Merge loaded data

                        // --- Post-load validation and cleanup ---
                        globalState.totalSessionHits = Number(globalState.totalSessionHits) || 0;
                        globalState.lifetimeSessionHits = Number(globalState.lifetimeSessionHits) || globalState.totalSessionHits;
                        globalState.totalCornerHits = Number(globalState.totalCornerHits) || 0;
                        globalState.systemFragments = Number(globalState.systemFragments) || 0;
                        globalState.hasRebootedOnce = Boolean(globalState.hasRebootedOnce);
                        globalState.lastSaveTimestamp = Number(globalState.lastSaveTimestamp) || null; // Ensure it's a number or null

                        // Ensure nextTvId is valid
                        globalState.nextTvId = Math.max(globalState.nextTvId || 0, (globalState.tvStates.reduce((max, tv) => Math.max(max, tv.id ?? -1), -1) + 1));
                        if (globalState.metaLevels.hasOwnProperty('logoSize')) { delete globalState.metaLevels.logoSize; }

                        selectedBuyAmount = globalState.selectedBuyAmount || 1;
                        if (selectedBuyAmount === 'max') selectedBuyAmount = Infinity;
                        else selectedBuyAmount = parseInt(selectedBuyAmount) || 1;

                        // *** Calculate Offline Progress ***
                        if (globalState.lastSaveTimestamp && typeof globalState.lastSaveTimestamp === 'number') {
                            const currentTime = Date.now();
                            let offlineTimeMs = currentTime - globalState.lastSaveTimestamp;

                            if (offlineTimeMs < 0) { // Clock went backwards? Ignore.
                                console.warn("Negative offline time detected, ignoring offline progress calculation.");
                                offlineTimeMs = 0;
                            }

                            // Apply min/max caps
                            offlineTimeMs = Math.min(offlineTimeMs, MAX_OFFLINE_TIME_MS);

                            if (offlineTimeMs >= MIN_OFFLINE_TIME_MS) {
                                // Ensure derived state is correct *before* calculating gains
                                updateAllTvsPostMeta(); // Apply meta upgrades first
                                recalculateGlobalSynergy();

                                console.log(`Calculating offline gains for ${Math.round(offlineTimeMs / 1000)} seconds...`);
                                offlineGains = calculateIdleGains(offlineTimeMs);

                                if (offlineGains > 0) {
                                    globalState.totalSessionHits += offlineGains;
                                    globalState.lifetimeSessionHits += offlineGains; // Add to both
                                    console.log(`Offline Gains: ${formatScore(offlineGains)} Hits`);
                                }
                            } else {
                                 console.log("Offline time too short for calculation:", offlineTimeMs, "ms");
                            }
                        } else {
                             console.log("No valid lastSaveTimestamp found for offline calculation.");
                        }


                        // Validate box data within each TV state *after* applying offline gains
                        globalState.tvStates.forEach((tv, index) => {
                            tv.index = index;
                            tv.boxes = Array.isArray(tv.boxes) ? tv.boxes : []; // Ensure boxes is an array
                            tv.boxes.forEach(box => {
                                box.x = (typeof box.x === 'number' && !isNaN(box.x)) ? box.x : 50;
                                box.y = (typeof box.y === 'number' && !isNaN(box.y)) ? box.y : 50;
                                box.vx = (typeof box.vx === 'number' && !isNaN(box.vx)) ? box.vx : (Math.random()-0.5)*BASE_SPEED_CONSTANT*0.5;
                                box.vy = (typeof box.vy === 'number' && !isNaN(box.vy)) ? box.vy : (Math.random()-0.5)*BASE_SPEED_CONSTANT*0.5;
                                box.element = null; // Ensure elements are recreated
                            });
                            tv.nextBoxId = Math.max(tv.nextBoxId || 0, (tv.boxes.reduce((max, box) => Math.max(max, box.id ?? -1), -1) + 1));
                        });
                        nextTvId = globalState.nextTvId;
                        boxCollisionTimers = {}; // Reset collision timers

                        updateAllTvsPostMeta(); // Re-apply meta upgrades to all loaded TVs
                        recalculateGlobalSynergy(); // Recalculate synergy

                        // Show combined notification *after* potential offline gains
                        showNotification(`Loaded Game State${offlineGains > 0 ? ` (+${formatScore(offlineGains)} Offline Hits)` : ''}`);
                        needsInitialization = false;
                    } else {
                        console.warn("Invalid save data structure found, resetting.", loadedState);
                        localStorage.removeItem(SAVE_KEY);
                    }
                } catch (e) {
                    console.error("Load Error:", e);
                    showNotification("Load Error! Resetting.");
                    localStorage.removeItem(SAVE_KEY);
                }
            }

            if (needsInitialization) {
                console.log("No valid save found or load error, initializing new game.");
                globalState = createDefaultGlobalState();
                updateAllTvsPostMeta(); // Apply initial meta state
                recalculateGlobalSynergy(); // Calculate initial synergy
                addTv(); // Add the first TV
                selectedBuyAmount = 1;
            }

             // Recreate DOM *after* all state modifications (including offline gains)
             recreateAllDomElements();
             checkMetaButtonVisibility();
             updateTotalHitsDisplay(); // Update displays with final values
             updateTotalCornerHitsDisplay();
             updateAllTvGlows();
             requestAnimationFrame(handleGlobalResize); // Initial resize check after DOM is ready
        }

        // --- Utility: Deep Merge ---
        function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }
        function deepMerge(target, source) {
            if (!isObject(target) || !isObject(source)) return source;
            let output = { ...target };
            Object.keys(source).forEach(key => {
                const targetValue = target[key];
                const sourceValue = source[key];
                if (sourceValue === undefined || sourceValue === null) {
                     // Keep target value if source is null/undefined, unless target also doesn't have it
                     if (!(key in output)) {
                         output[key] = undefined;
                     }
                    return;
                }
                if (isObject(sourceValue)) {
                    if (isObject(targetValue)) {
                        output[key] = deepMerge(targetValue, sourceValue);
                    } else {
                        output[key] = JSON.parse(JSON.stringify(sourceValue)); // Deep copy source object
                    }
                } else if (Array.isArray(sourceValue)) {
                     // Overwrite arrays completely, don't merge them element by element
                    output[key] = JSON.parse(JSON.stringify(sourceValue));
                } else {
                    output[key] = sourceValue; // Overwrite primitives
                }
            });
             // Ensure keys only present in target are kept
            Object.keys(target).forEach(key => {
                if (!(key in source)) {
                    output[key] = target[key];
                }
            });
            return output;
        }


        // --- State Initialization ---
        function createDefaultTvState(index, id) {
            const tvState = {
                index: index, id: id,
                boxes: [], nextBoxId: 0,
                upgrades: { hitValue: 0, speed: 0, cornerBonusFlat: 0, cornerBonusPercent: 0, boxCollisionValue: 0 },
                // Derived stats (will be recalculated)
                hitValue: 1, cornerHitBaseBonus: 1000, cornerHitPercentBonus: 0, boxCollisionValue: 2,
                baseSpeedFactorMeta: 1.0, // Affected by meta upgrades
                // Runtime properties (not saved)
                screenWidth: 0, screenHeight: 0,
                dynamicBoxWidth: 0, dynamicBoxHeight: 0,
                elements: null,
                resizeRetryTimeout: null, adjustRetryTimeout: null,
            };
            recalculateDerivedTvState(tvState);
            return tvState;
        }
        function createDefaultGlobalState() {
            const now = Date.now();
            return {
                systemFragments: 0,
                totalSessionHits: 0,
                lifetimeSessionHits: 0,
                totalCornerHits: 0,
                tvStates: [],
                metaLevels: { fragmentGain: 0, baseSpeed: 0, baseMaxBoxes: 0, tvSynergyBonus: 0 },
                synergyBonus: 1.0,
                maxBoxesPerTv: 2,
                hasRebootedOnce: false,
                nextTvId: 0,
                selectedBuyAmount: 1,
                lastSaveTimestamp: now, // Set initial timestamp for new games
            };
        }

        // --- Idle Progress Calculation ---
        // This function now serves both offline and tab-hidden calculations
        function calculateIdleGains(idleTimeMs) {
            if (!globalState || !globalState.tvStates || idleTimeMs <= 0) return 0;

            // Ensure derived stats are current before calculation
             // Not strictly needed here if called after updateAllTvsPostMeta() in loadGame,
             // but good practice if called elsewhere later.
            // updateAllTvsPostMeta();
            // recalculateGlobalSynergy();

            let totalIdleHitsPerSec = 0;
            globalState.tvStates.forEach(tvState => {
                if (tvState.boxes.length === 0) return;

                // Use current derived values (already calculated)
                const tvSpeedFactor = deriveTvSpeedFactor(tvState, tvState.upgrades.speed);
                const tvHitValue = tvState.hitValue; // Already calculated
                const numBoxes = tvState.boxes.length;

                // Simple estimation: hits proportional to boxes, speed, and base hit value
                const hitsPerSecPerBox = IDLE_HITS_PER_SEC_PER_BOX_BASE_FACTOR * tvSpeedFactor;
                const idleHitsPerTvPerSec = numBoxes * hitsPerSecPerBox * tvHitValue;
                totalIdleHitsPerSec += idleHitsPerTvPerSec;
            });

            // Apply global synergy and dev factor
            const totalEffectiveIdleHitsPerSec = totalIdleHitsPerSec * globalState.synergyBonus * DEV_SPEED_FACTOR;
            const totalGainedHits = totalEffectiveIdleHitsPerSec * (idleTimeMs / 1000);

            // console.log(`Idle Calc: ${idleTimeMs}ms -> ${totalIdleHitsPerSec.toFixed(2)} base HPS -> ${totalEffectiveIdleHitsPerSec.toFixed(2)} effective HPS -> ${Math.floor(totalGainedHits)} Hits`);

            return Math.max(0, Math.floor(totalGainedHits)); // Ensure non-negative integer
        }

        // --- Handle Visibility Change for *Tab Hiding* Idle ---
        function handleVisibilityChange() {
            const now = performance.now(); // Use performance.now() for tab visibility
            if (document.hidden) {
                timeHidden = now; // Record time when tab became hidden using performance timer
                // Save game state when becoming hidden (includes Date.now() timestamp)
                saveGame();
                // Optional: Clear the game loop interval to save CPU when hidden
                // if (gameLoopInterval) {
                //     clearInterval(gameLoopInterval);
                //     gameLoopInterval = null;
                // }
            } else {
                if (timeHidden !== null) { // Coming back from hidden state *in the same session*
                    const idleTimeMs = now - timeHidden;
                    if (idleTimeMs > 1000) { // Only calculate if hidden for > 1 second
                        // Call the same gain calculation function
                        const gainedHits = calculateIdleGains(idleTimeMs);
                        if (gainedHits > 0) {
                            globalState.totalSessionHits += gainedHits;
                            globalState.lifetimeSessionHits += gainedHits; // Add to both counts
                            showNotification(`Gained ${formatScore(gainedHits)} Hits while tab was inactive.`);
                            updateTotalHitsDisplay();
                            updateAllTvGlows();
                            // Modal buttons update automatically if open via game loop
                        }
                    }
                    timeHidden = null; // Reset hidden time tracker
                }
                // Re-sync animation timestamp and ensure loop is running
                lastTimestamp = performance.now(); // Reset animation timer
                 if (!gameLoopInterval && !document.hidden) { // Restart loop if needed
                     gameLoopInterval = setInterval(() => gameLoop(performance.now()), TICK_RATE_MS);
                 }
                 // Trigger resize/position checks on becoming visible again
                 requestAnimationFrame(handleGlobalResize);
                 globalState.tvStates.forEach((tv, index) => checkAndAdjustBoxPositions(index));
            }
        }


        // --- Initialization ---
        async function init() {
             const startTime = performance.now();

             try {
                 console.log("Preloading images...");
                 await preloadImages([DVD_LOGO_URL, TV_BACKGROUND_URL]);
                 console.log("Images preloaded.");
             } catch (error) {
                 console.error("Image preloading issues:", error);
             }

             // Load game *first* to potentially apply offline gains
             loadGame();

             // --- Event Listeners ---
             modalCloseButton.addEventListener('click', closeUpgradeModal);
             upgradeModal.addEventListener('click', (e) => { if (e.target === upgradeModal) closeUpgradeModal(); }); // Close on backdrop click
             metaMenuButton.addEventListener('click', () => openUpgradeModal(-1)); // Open meta modal
             window.addEventListener('resize', handleGlobalResize); // Handle window resizing
             document.addEventListener('visibilitychange', handleVisibilityChange); // Handle tab visibility

             // --- Start Game Loop ---
             lastTimestamp = performance.now(); // Set initial timestamp for game loop
             lastSaveTime = Date.now(); // Set initial save time check
             // Start loop only if tab is initially visible
             if (!document.hidden) {
                gameLoopInterval = setInterval(() => gameLoop(performance.now()), TICK_RATE_MS);
             }
             console.log("Initialization complete.");

             // --- Loading screen minimum time ---
             const endTime = performance.now();
             const elapsedTime = endTime - startTime;
             const delayTime = Math.max(0, MIN_LOADING_TIME_MS - elapsedTime);

             console.log(`Initialization took ${elapsedTime.toFixed(0)}ms. Delaying hide by ${delayTime.toFixed(0)}ms.`);

             // Hide loading screen after minimum time + fade out
             setTimeout(() => {
                 if (loadingScreen) {
                     loadingScreen.classList.add('hidden');
                     setTimeout(() => {
                         if (loadingScreen && loadingScreen.parentNode) {
                              loadingScreen.parentNode.removeChild(loadingScreen);
                         }
                     }, 500); // Match the CSS transition duration
                 }
             }, delayTime);
        }

        // --- Start ---
        if (document.readyState === 'loading') {
             document.addEventListener('DOMContentLoaded', init);
        } else {
             init(); // Already loaded
        }

    })();
</script>

</body>
</html>
