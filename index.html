
 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DVD Video Idle</title>
    <style>
        :root {
            --tv-bg: #282828;
            --screen-bg: #111;
            --text-color: #eee;
            --border-color: #444;
            --highlight-color-hits: #0df; /* Teal */
            --highlight-color-corners: #0f0; /* Still used for text color */
            --highlight-color-wall: #0df;
            --meta-color: #f0f; /* Pink */
            --collision-color: #f90;
            --tv-hover-light: #f50;
            --tv-upgrade-light: var(--highlight-color-hits);
            --modal-bg-translucent: rgba(25, 25, 25, 0.92);
            --modal-border: #555;
            --button-bg: #4a4a4a;
            --button-hover: #666;
            --button-active: #777;
            --disabled-color: #777;
            --accent-color: #eee;
            --main-bg-color: #000;
        }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--main-bg-color);
            font-family: 'Courier New', Courier, monospace; color: var(--text-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
        }

        /* --- Loading Screen Styles --- */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--main-bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
            opacity: 1;
        }

        #loading-screen .loading-logo-container {
            width: 50%;
            max-width: 350px;
            aspect-ratio: 960 / 500;
            margin-bottom: 20px;
            background-color: var(--highlight-color-hits);
            mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            -webkit-mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png');
            mask-size: contain;
            -webkit-mask-size: contain;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
            mask-position: center;
            -webkit-mask-position: center;
        }
        #loading-screen .loading-logo-container img {
            opacity: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #loading-screen .loading-text {
            font-family: 'Futura Medium', Futura, 'Century Gothic', AppleGothic, sans-serif;
            font-size: clamp(3rem, 10vw, 5rem);
            color: var(--meta-color);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 0;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .hidden {
            display: none !important;
        }
        /* --- End Loading Screen Styles --- */


        #game-container {
            display: flex; flex-direction: column; align-items: center;
            justify-content: flex-start;
            width: 100%; height: 100%; padding: 10px; box-sizing: border-box; position: relative;
        }

        #top-info-bar {
            position: absolute; top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: center; align-items: center;
            gap: 20px;
            z-index: 10; pointer-events: none;
            flex-wrap: wrap;
        }
        .top-info-display {
            font-size: clamp(1.1rem, 2.5vw, 1.6rem); font-weight: bold;
            background-color: rgba(10, 10, 10, 0.6); padding: 3px 10px;
            border-radius: 5px; flex-shrink: 0; text-align: center;
        }
        #total-hits-display {
            color: var(--highlight-color-hits);
            text-shadow: 0 0 5px var(--highlight-color-hits);
        }

        #tvs-display-area {
            display: flex; flex-wrap: wrap; justify-content: center;
            align-items: flex-start;
            gap: 15px;
            width: 100%; max-width: 1400px;
            padding: 15px; box-sizing: border-box;
            margin-top: 65px;
            max-height: calc(100vh - 110px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tv-instance-container {
            display: flex; flex-direction: column; align-items: center;
            width: clamp(300px, 35vw, 420px);
            flex-shrink: 0; position: relative;
        }

        .tv-frame {
            background-image: url('https://00s.myretrotvs.com/img/tvbackclean.webp');
            background-size: 100% calc(100% / 0.84);
            background-position: center top;
            background-repeat: no-repeat;
            position: relative;
            width: 100%;
            aspect-ratio: 1.25 / 0.84;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s ease;
            overflow: hidden;
        }

        .tv-screen {
            position: absolute;
            top: 9.4%;
            height: 74.1%;
            left: 12%;
            width: 76%;
            background-color: var(--screen-bg);
            overflow: hidden;
            border-radius: 5px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
            filter: url(#crt-effect);
        }

        .tv-screen::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.20) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.04), rgba(0, 255, 0, 0.015), rgba(0, 0, 255, 0.04)); background-size: 100% 2px, 3px 100%; z-index: 2; pointer-events: none; animation: crt-scanline 100s linear infinite; }
        @keyframes crt-scanline { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

        .box { position: absolute; background-color: #ffffff; mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png'); -webkit-mask-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png'); mask-size: contain; -webkit-mask-size: contain; mask-repeat: no-repeat; -webkit-mask-repeat: no-repeat; mask-position: center; -webkit-mask-position: center; z-index: 1; filter: brightness(1.05); will-change: transform; }

        .spark-particle { position: absolute; width: 2px; height: 2px; border-radius: 50%; pointer-events: none; z-index: 10; opacity: 1; background-color: #fff; transition: transform 0.6s cubic-bezier(0.1, 0.7, 0.9, 1), opacity 0.6s ease-out; box-shadow: 0 0 3px #fff; }

        .tv-power-light {
            position: absolute;
            bottom: 2%;
            left: 53%;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #330800;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.5);
            opacity: 0;
            transition: background-color 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            z-index: 5;
        }

        .tv-frame:hover .tv-power-light {
            opacity: 1;
            background-color: var(--tv-hover-light);
            box-shadow: 0 0 5px 2px var(--tv-hover-light),
                        0 0 8px 3px rgba(255, 80, 0, 0.5),
                        inset 0 0 2px rgba(255, 255, 255, 0.3);
        }

        .tv-frame.can-upgrade-glow .tv-power-light {
            opacity: 1;
            background-color: var(--tv-upgrade-light);
            box-shadow: 0 0 6px 3px var(--tv-upgrade-light),
                        0 0 10px 4px rgba(0, 221, 255, 0.6),
                        inset 0 0 2px rgba(255, 255, 255, 0.4);
        }

        #upgrade-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; z-index: 1000; }
        #upgrade-modal.show { display: flex; }
        .modal-content { background-color: var(--modal-bg-translucent); padding: 20px 25px; border-radius: 10px; border: 1px solid var(--modal-border); box-shadow: 0 5px 25px rgba(0,0,0,0.5); width: 90%; max-width: 650px; max-height: 85vh; overflow-y: auto; position: relative; }
        .modal-header { font-size: clamp(1.2rem, 3vw, 1.6rem); font-weight: bold; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); text-align: center; color: var(--accent-color); }
        .modal-header .tv-stats { font-size: 0.7em; font-weight: normal; color: #bbb; display: block; margin-top: 5px; }
        .modal-close-button { position: absolute; top: 10px; right: 15px; font-size: 1.8rem; color: var(--disabled-color); background: none; border: none; cursor: pointer; padding: 0; line-height: 1; }
        .modal-close-button:hover { color: var(--text-color); }
        #modal-buy-amount-container { display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; }
        .buy-amount-button { background-color: var(--button-bg); color: var(--accent-color); border: 1px solid var(--border-color); padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: background-color 0.2s; }
        .buy-amount-button:hover { background-color: var(--button-hover); }
        .buy-amount-button.active { background-color: var(--button-active); border-color: #999; font-weight: bold; }
        .upgrades-section { display: grid; grid-template-columns: repeat(auto-fit, minmax(125px, 1fr)); gap: 10px; width: 100%; margin-bottom: 15px;}
        .upgrade-button { background-color: var(--button-bg); color: var(--accent-color); border: 1px solid var(--border-color); padding: 10px 6px; border-radius: 6px; cursor: pointer; font-size: clamp(0.7rem, 2vw, 0.85rem); transition: background-color 0.2s, transform 0.1s; text-align: center; min-height: 85px; display: flex; flex-direction: column; justify-content: space-between; align-items: center; }
        .upgrade-button:hover:not(:disabled) { background-color: var(--button-hover); }
        .upgrade-button:active:not(:disabled) { transform: scale(0.96); }
        .upgrade-button:disabled { background-color: #333; color: var(--disabled-color); cursor: not-allowed; opacity: 0.6; }
        .upgrade-description { flex-grow: 1; margin-bottom: 4px; }
        .upgrade-description strong { font-size: 1.1em; display: block; margin-bottom: 3px; line-height: 1.1; }
        .upgrade-cost { font-size: 0.9em; font-weight: bold; margin-top: auto; }
        .upgrade-cost.hit { color: var(--highlight-color-hits); }
        .upgrade-cost.meta { color: var(--meta-color); }
        .upgrade-button:disabled .upgrade-cost { color: var(--disabled-color); opacity: 0.8; }
        #modal-reboot-section-container { width: 100%; }
        #reboot-section { border-top: 1px dashed var(--meta-color); margin-top: 15px; padding-top: 15px; text-align: center; }
        #reboot-info { margin-bottom: 8px; font-size: 0.85em; color: #ccc; }
        #reboot-gain-preview { margin-bottom: 12px; font-weight: bold; font-size: 0.9em; }

        /* --- START: Progress Bar Styles --- */
        #reboot-progress-container {
            width: 85%;
            max-width: 300px;
            margin: 10px auto 15px auto; /* Centered, with margin */
            background-color: #383838;
            border-radius: 6px;
            height: 22px;
            position: relative;
            overflow: hidden; /* Clip the inner bar */
            border: 1px solid #555;
        }
        #reboot-progress-bar {
            height: 100%;
            width: 0%; /* Updated by JS */
            background-color: var(--meta-color); /* Use meta color */
            border-radius: 5px; /* Match container, slightly smaller if needed */
            transition: width 0.3s ease-out;
            position: relative; /* For text positioning context */
        }
        #reboot-progress-text {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.6);
            white-space: nowrap; /* Prevent wrapping */
            z-index: 1; /* Ensure text is above the bar fill */
            padding: 0 5px; /* Prevent text touching edges */
            box-sizing: border-box;
        }
        /* --- END: Progress Bar Styles --- */

        #reboot-button { background-color: var(--meta-color); color: #fff; border: 1px solid #505; padding: 8px 18px; border-radius: 5px; cursor: pointer; font-size: 0.9rem; font-weight: bold; transition: background-color 0.2s, transform 0.1s; }
        #reboot-button:hover:not(:disabled) { background-color: #ff40ff; }
        #reboot-button:active:not(:disabled) { transform: scale(0.96); }
        #reboot-button:disabled { background-color: #606; color: var(--disabled-color); cursor: not-allowed; }
        #meta-menu-button { position: fixed; bottom: 15px; right: 15px; background-color: var(--meta-color); color: white; border: 1px solid #505; border-radius: 50%; width: 45px; height: 45px; font-size: 1.5rem; cursor: pointer; z-index: 900; display: none; justify-content: center; align-items: center; box-shadow: 0 3px 8px rgba(0,0,0,0.4); transition: background-color 0.2s, transform 0.2s; display: none; }
        #meta-menu-button:hover { background-color: #ff40ff; transform: scale(1.1); }
        #meta-menu-button.show { display: flex; }
        #notification { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); background-color: rgba(30, 30, 30, 0.85); color: white; padding: 8px 15px; border-radius: 5px; font-size: 0.85rem; opacity: 0; transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out; pointer-events: none; z-index: 1100; text-align: center; border: 1px solid #555;}
        #notification.show { opacity: 1; top: 25px; }

        .float-text { position: absolute; font-family: 'Courier New', Courier, monospace; font-weight: bold; z-index: 100; pointer-events: none; opacity: 0; white-space: pre; text-align: center; will-change: transform, opacity; }
        .corner-hit-text { top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--highlight-color-corners); font-size: clamp(1.5rem, 4vw, 2.4rem); text-shadow: 1px 1px #111, 0 0 15px var(--highlight-color-corners), 0 0 5px white; animation: cornerHitAnim 1.3s ease-out forwards; z-index: 101; }
        .collision-text { color: var(--collision-color); font-size: clamp(0.9rem, 2.5vw, 1.4rem); text-shadow: 1px 1px #111, 0 0 8px var(--collision-color); animation: floatFadeUp 0.9s ease-out forwards; z-index: 99; }
        .wall-hit-text { color: var(--highlight-color-wall); font-size: clamp(0.8rem, 2.2vw, 1.2rem); text-shadow: 1px 1px #111, 0 0 6px var(--highlight-color-wall); animation: floatFadeUp 0.8s ease-out forwards; z-index: 98; }

        @keyframes floatFadeUp { 0% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -150%) scale(0.8); } }
        @keyframes cornerHitAnim { 0% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(0.95); } 100% { opacity: 0; transform: translate(-50%, -180%) scale(0.7); } }

        svg { position:absolute; height: 0; width: 0; }

         /* Dev Panel Specific Styles */
        #dev-panel label {
            color: #ccc;
            font-size: 0.8rem;
            display: block;
            margin-bottom: 2px;
        }
        #dev-panel input[type="number"] {
            width: 60px;
            padding: 3px;
            background-color: #222;
            border: 1px solid #555;
            color: #eee;
            font-size: 0.9rem;
            border-radius: 3px;
             margin-right: 5px;
        }
    </style>
</head>
<body>

<!-- Loading Screen HTML -->
<div id="loading-screen">
    <div class="loading-logo-container">
         <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png" alt="">
    </div>
    <p class="loading-text">IDLE</p>
</div>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <defs>
    <filter id="crt-effect">
      <feGaussianBlur stdDeviation="0.2" result="blurred"/>
      <feComponentTransfer in="blurred" result="contrastBoost">
         <feFuncR type="linear" slope="1.03" intercept="-0.005"/>
         <feFuncG type="linear" slope="1.03" intercept="-0.005"/>
         <feFuncB type="linear" slope="1.03" intercept="-0.005"/>
      </feComponentTransfer>
    </filter>
  </defs>
</svg>

<div id="game-container">
    <div id="top-info-bar">
        <div id="total-hits-display" class="top-info-display">Hits: 0</div>
    </div>
    <div id="tvs-display-area"></div>
    <button id="meta-menu-button" aria-label="Meta Upgrades & Reboot">✵</button>
</div>

<div id="upgrade-modal">
    <div class="modal-content">
        <button class="modal-close-button" aria-label="Close Modal">×</button>
        <div class="modal-header">
            <span id="modal-title">Upgrades</span>
            <span id="modal-tv-stats" class="tv-stats"></span>
        </div>
        <div id="modal-buy-amount-container"></div>
        <div id="modal-upgrades-section" class="upgrades-section"></div>
        <div id="modal-reboot-section-container"></div>
    </div>
</div>

<div id="reboot-section-template" style="display: none;">
    <div id="reboot-section">
        <div id="reboot-info">Reboot to gain Static Charges based on total Hits this session.</div>
        <div id="reboot-gain-preview">Gain ~0 Static Charges</div>
        <!-- START: Progress Bar HTML Structure -->
        <div id="reboot-progress-container">
          <span id="reboot-progress-text">Calculating...</span>
            <div id="reboot-progress-bar">
            </div>
        </div>
        <!-- END: Progress Bar HTML Structure -->
        <button id="reboot-button" disabled>Reboot System</button>
    </div>
</div>


<div id="notification"></div>

<!-- DEV Tools -->
<button id="dev-button" style="position: fixed; bottom: 15px; left: 15px; z-index: 950; padding: 8px 12px; background-color: #500; color: white; border: 1px solid #a00; border-radius: 5px; cursor: pointer; font-family: monospace; font-size: 0.9rem;">
    DEV
</button>
<div id="dev-panel" class="hidden" style="position: fixed; bottom: 55px; left: 15px; z-index: 951; background-color: rgba(40, 0, 0, 0.85); border: 1px solid #a00; border-radius: 5px; padding: 10px; display: flex; flex-direction: column; gap: 8px;">
    <button id="dev-simulate-corner" style="background-color: #333; color: #eee; border: 1px solid #666; padding: 5px; cursor: pointer;">Simulate Corner Hit</button>
    <div>
        <label for="dev-speed-input">Score Factor:</label>
        <input type="number" id="dev-speed-input" name="dev-speed-input" min="0.1" step="0.1" value="1.0">
    </div>
    <button id="dev-hard-reset" style="background-color: #800; color: white; border: 1px solid #f00; padding: 5px; cursor: pointer; margin-top: 5px;">Hard Reset Game</button>
</div>
<!-- End DEV Tools -->

<script>
    (function() {

        // --- Game Constants & Variables ---
        let devSpeedFactor = 1;
        const DVD_LOGO_URL = 'https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/DVD_VIDEO_logo.png/960px-DVD_VIDEO_logo.png';
        const TV_BACKGROUND_URL = 'https://00s.myretrotvs.com/img/tvbackclean.webp';
        const BASE_LOGO_HEIGHT_SCREEN_RATIO = 0.14;
        const BASE_BOX_ASPECT_RATIO = 1.6;
        const BASE_SPEED_CONSTANT = 1.0;
        const MAX_BOXES_PER_TV = 15;
        const SAVE_VERSION = 'v0.4';
        const SAVE_KEY = `dvdVideoIdleSave_${SAVE_VERSION}`;
        const TICK_RATE_MS = 16;
        const COLLISION_ENERGY_LOSS = 0.96;
        const BOX_COLLISION_COOLDOWN_MS = 100;
        const BOX_COLLISION_SEPARATION_BUFFER = 0.1;
        const TV_COST_SCALING_FACTOR = 1.8;
        const MAX_BULK_BUY_CHECK = 10000;
        const IDLE_HITS_PER_SEC_PER_BOX_BASE_FACTOR = 0.6;
        const MIN_LOADING_TIME_MS = 1500; // Reduced slightly
        const MIN_OFFLINE_TIME_MS = 60 * 1000;
        const MAX_OFFLINE_TIME_MS = 14 * 24 * 60 * 60 * 1000;
        const CORNERS_SUCK_TIME_SCALE_FACTOR = 6000;
        const CORNERS_SUCK_LEVEL_SCALE_FACTOR = 0.01;
        const CORNERS_SUCK_MAX_MULTIPLIER = 3.0;
        const REBOOT_MIN_HITS_FOR_FIRST_CHARGE = 5000; // Explicit constant
        const FIND_THRESHOLD_MAX_ITERATIONS = 1000; // Safety limit for search
        const FIND_THRESHOLD_MAX_HITS = 1e24; // Practical upper limit for search


        // --- DOM Element Selection ---
        const loadingScreen = document.getElementById('loading-screen');
        const totalHitsDisplay = document.getElementById('total-hits-display');
        const tvsDisplayArea = document.getElementById('tvs-display-area');
        const notificationElement = document.getElementById('notification');
        const upgradeModal = document.getElementById('upgrade-modal');
        const modalContent = upgradeModal.querySelector('.modal-content');
        const modalCloseButton = upgradeModal.querySelector('.modal-close-button');
        const modalTitle = upgradeModal.querySelector('#modal-title');
        const modalTvStats = upgradeModal.querySelector('#modal-tv-stats');
        const modalBuyAmountContainer = upgradeModal.querySelector('#modal-buy-amount-container');
        const modalUpgradesContainer = upgradeModal.querySelector('#modal-upgrades-section');
        const modalRebootContainer = upgradeModal.querySelector('#modal-reboot-section-container');
        const metaMenuButton = document.getElementById('meta-menu-button');

        // --- Game State ---
        let globalState;
        let selectedTvIndex = -1;
        let gameLoopInterval = null;
        let lastTimestamp = 0;
        let lastSaveTime = 0;
        let nextTvId = 0;
        let boxCollisionTimers = {};
        let selectedBuyAmount = 1;
        let timeHidden = null;
        let hitsThresholdCache = {}; // Cache for findHitsThreshold results

        // --- Utility Functions ---
        const calculateCost = (baseCost, level, factor = 1.5, tvIndex = -1) => { let cost = baseCost * Math.pow(factor, level); if (tvIndex >= 0 && tvIndex > 0) { cost *= Math.pow(TV_COST_SCALING_FACTOR, tvIndex); } return Math.max(1, Math.floor(cost)); };
        const formatScore = (value) => { const V = Math.floor(value); if (V < 1e4) return V.toLocaleString(); if (V < 1e6) return (V / 1e3).toFixed(V < 100e3 ? 1 : 0) + 'K'; if (V < 1e9) return (V / 1e6).toFixed(V < 100e6 ? 1 : 0) + 'M'; if (V < 1e12) return (V / 1e9).toFixed(V < 100e9 ? 1 : 0) + 'B'; if (V < 1e15) return (V / 1e12).toFixed(V < 100e12 ? 1 : 0) + 'T'; if (V < 1e18) return (V / 1e15).toFixed(V < 100e15 ? 1 : 0) + 'Qd'; return (V / 1e18).toFixed(1) + 'Qn'; };
        function getRandomColor() { let r, g, b; let color = '#'; const letters = '0123456789ABCDEF'; do { color = '#'; for (let i = 0; i < 6; i++) { color += letters[Math.floor(Math.random() * 16)]; } r = parseInt(color.substring(1, 3), 16); g = parseInt(color.substring(3, 5), 16); b = parseInt(color.substring(5, 7), 16); } while (r + g + b < 450 || (r > 200 && g > 200 && b > 200)); return color; }
        function getBoxCollisionKey(id1, id2) { return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`; }

        // --- Image Preloading ---
        function preloadImages(urls) {
            const promises = urls.map(url => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = resolve;
                    img.onerror = (err) => {
                        console.error(`Failed to load image: ${url}`, err);
                        resolve();
                    };
                    img.src = url;
                });
            });
            return Promise.all(promises);
        }

        // --- TV & Box Creation / Management ---
        function createTvDom(tvState) {
            const container = document.createElement('div');
            container.classList.add('tv-instance-container');
            container.dataset.tvIndex = tvState.index;

            const tvFrame = document.createElement('div');
            tvFrame.classList.add('tv-frame');
            tvFrame.id = `tv-frame-${tvState.id}`;
            tvFrame.onclick = (e) => { e.stopPropagation(); openUpgradeModal(tvState.index); };

            const tvScreen = document.createElement('div');
            tvScreen.classList.add('tv-screen');
            tvScreen.id = `tv-screen-${tvState.id}`;
            tvFrame.appendChild(tvScreen);

            const powerLight = document.createElement('div');
            powerLight.classList.add('tv-power-light');
            tvFrame.appendChild(powerLight);

            container.appendChild(tvFrame);
            tvsDisplayArea.appendChild(container);

            tvState.elements = {
                container,
                frame: tvFrame,
                screen: tvScreen,
                powerLight: powerLight
            };
            resizeTvScreen(tvState);
            updateTvGlow(tvState.index);
        }

        function createBoxElement(tvState, boxData) {
            if (!tvState.elements || !tvState.elements.screen) {
                console.error("TV screen element not found when creating box for TV", tvState.id);
                return null;
            }
            if (!tvState.screenWidth || !tvState.screenHeight) {
                 console.warn("Screen dimensions not ready for TV", tvState.id, "retrying box creation soon.");
                 if(!boxData.element){
                     setTimeout(() => {
                        if(globalState && globalState.tvStates[tvState.index]) {
                            const currentTvState = globalState.tvStates[tvState.index];
                            const reBox = currentTvState.boxes.find(b => b.id === boxData.id && !b.element);
                            if (reBox && !reBox.element) {
                                reBox.element = createBoxElement(currentTvState, reBox);
                                if(reBox.element) {
                                    reBox.element.style.transform = `translate(${reBox.x}px, ${reBox.y}px)`;
                                }
                            }
                        }
                     }, 100);
                 }
                 return null;
             }

            const boxElement = document.createElement('div');
            boxElement.classList.add('box');
            boxElement.id = `tv${tvState.id}-box${boxData.id}`;
            boxElement.style.width = `${tvState.dynamicBoxWidth}px`;
            boxElement.style.height = `${tvState.dynamicBoxHeight}px`;
            boxElement.style.transform = `translate(${boxData.x}px, ${boxData.y}px)`;
            boxElement.style.backgroundColor = getRandomColor();
            boxElement.style.maskImage = `url('${DVD_LOGO_URL}')`;
            boxElement.style.webkitMaskImage = `url('${DVD_LOGO_URL}')`;
            tvState.elements.screen.appendChild(boxElement);
            return boxElement;
        }

        function addBoxToTv(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
            const currentMaxBoxes = globalState.maxBoxesPerTv;
            if (!tvState || tvState.boxes.length >= currentMaxBoxes) return false;

            if (!tvState.elements || !tvState.elements.screen || !tvState.screenWidth || !tvState.screenHeight) {
                 console.warn(`TV ${tvState.id}: Screen dimensions not ready, delaying box add.`);
                 resizeTvScreen(tvState);
                 setTimeout(() => addBoxToTv(tvIndex), 100);
                 return false;
             }

            const id = tvState.nextBoxId++;
            const speed = getCurrentTvSpeed(tvState);
            const baseAngle = Math.PI / 4;
            const randomOffset = (Math.random() - 0.5) * (Math.PI / 6);
            const randomQuadrant = Math.floor(Math.random() * 4);
            const angle = baseAngle + randomOffset + randomQuadrant * (Math.PI / 2);

            let startX, startY, attempts = 0, tooClose;
            do {
                startX = Math.random() * (tvState.screenWidth - tvState.dynamicBoxWidth);
                startY = Math.random() * (tvState.screenHeight - tvState.dynamicBoxHeight);
                tooClose = tvState.boxes.some(eB => {
                    const dx=startX-eB.x; const dy=startY-eB.y;
                    return (dx*dx+dy*dy) < Math.pow(tvState.dynamicBoxWidth*1.5, 2);
                });
                attempts++;
            } while (tooClose && attempts < 10);

            const newBox = {
                id: id,
                x: startX,
                y: startY,
                vx: Math.cos(angle) * speed * 0.7,
                vy: Math.sin(angle) * speed * 0.7,
                element: null
            };

            newBox.element = createBoxElement(tvState, newBox);

            if (newBox.element || !tvState.screenWidth) {
                 tvState.boxes.push(newBox);
                 updateTvGlow(tvIndex);
                 return true;
            } else {
                 console.warn("Box element creation potentially delayed for TV", tvState.id);
                 tvState.boxes.push(newBox);
                 updateTvGlow(tvIndex);
                 return true;
            }
        }

        function addTv() {
            const newIndex = globalState.tvStates.length;
            const newId = nextTvId++;
            globalState.nextTvId = nextTvId;
            const newTvState = createDefaultTvState(newIndex, newId);
            applyMetaUpgradesToTv(newTvState);
            globalState.tvStates.push(newTvState);
            createTvDom(newTvState);
            addBoxToTv(newIndex);
            recalculateGlobalSynergy();
            updateMetaUpgradeButtonsIfVisible();
            updateAllTvGlows();
            showNotification(`TV #${newId} Online`);
            return newTvState;
        }
        function removeAllDomElements() { tvsDisplayArea.innerHTML = ''; globalState.tvStates.forEach(tv => tv.elements = null); }
        function recreateAllDomElements() {
             removeAllDomElements();
             globalState.tvStates.forEach(tvState => {
                createTvDom(tvState);
                tvState.boxes.forEach(box => {
                    if (typeof box.x !== 'number' || typeof box.y !== 'number' || typeof box.vx !== 'number' || typeof box.vy !== 'number' || isNaN(box.x) || isNaN(box.y) || isNaN(box.vx) || isNaN(box.vy)) {
                        console.warn(`Invalid box data on load for TV ${tvState.id} box ${box.id}. Resetting position/velocity.`);
                        box.x = 50; box.y = 50; box.vx = (Math.random()-0.5)*0.5; box.vy = (Math.random()-0.5)*0.5;
                    }
                    box.element = null;
                    box.element = createBoxElement(tvState, box);
                    if (!box.element && tvState.screenWidth) {
                        console.warn(`Box element recreation potentially delayed for TV ${tvState.id} box ${box.id}`);
                    }
                 });
                 resizeTvScreen(tvState);
                 checkAndAdjustBoxPositions(tvState.index);
                 updateTvGlow(tvState.index);
             });
             updateAllTvGlows();
        }
         function clearTvScreenBoxes(tvIndex) {
             const tvState = globalState.tvStates[tvIndex];
             if (tvState && tvState.elements && tvState.elements.screen) {
                 tvState.elements.screen.innerHTML = '';
                 tvState.boxes.forEach(box => box.element = null);
             }
         }

        // --- Sizing and Positioning ---
        function resizeTvScreen(tvState) {
            if (!tvState.elements || !tvState.elements.screen) {
                 if (globalState && globalState.tvStates[tvState.index] && !tvState.elements) {
                     console.warn(`Elements missing for TV ${tvState.id}, attempting recreation.`);
                     recreateAllDomElements();
                 }
                 return;
            }
            const screenRect = tvState.elements.screen.getBoundingClientRect();

            if (screenRect.width <= 0 || screenRect.height <= 0) {
                if (!document.hidden) {
                    if (!tvState.resizeRetryTimeout) {
                         tvState.resizeRetryTimeout = setTimeout(() => {
                             tvState.resizeRetryTimeout = null;
                             resizeTvScreen(tvState);
                         }, 150);
                     }
                }
                return;
            }

            const oldWidth = tvState.screenWidth;
            const oldHeight = tvState.screenHeight;

            tvState.screenWidth = screenRect.width;
            tvState.screenHeight = screenRect.height;
            tvState.dynamicBoxHeight = Math.max(8, Math.floor(tvState.screenHeight * BASE_LOGO_HEIGHT_SCREEN_RATIO));
            tvState.dynamicBoxWidth = Math.floor(tvState.dynamicBoxHeight * BASE_BOX_ASPECT_RATIO);

            if (Math.abs(tvState.screenWidth - oldWidth) > 1 || Math.abs(tvState.screenHeight - oldHeight) > 1) {
                tvState.boxes.forEach(box => {
                    if (box.element) {
                        box.element.style.width = `${tvState.dynamicBoxWidth}px`;
                        box.element.style.height = `${tvState.dynamicBoxHeight}px`;
                    }
                    box.x = Math.max(0, Math.min(box.x ?? tvState.screenWidth/2, tvState.screenWidth - tvState.dynamicBoxWidth));
                    box.y = Math.max(0, Math.min(box.y ?? tvState.screenHeight/2, tvState.screenHeight - tvState.dynamicBoxHeight));
                     if (box.element) {
                         box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                     }
                });
            }
        }

        function handleGlobalResize() {
            globalState.tvStates.forEach(tvState => {
                resizeTvScreen(tvState);
            });
        }
        function checkAndAdjustBoxPositions(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
             if (!tvState || !tvState.screenWidth || !tvState.screenHeight || !tvState.dynamicBoxWidth || tvState.screenWidth <= 0 || tvState.screenHeight <= 0) {
                 if (!document.hidden && !tvState.adjustRetryTimeout) {
                     tvState.adjustRetryTimeout = setTimeout(() => {
                         tvState.adjustRetryTimeout = null;
                         checkAndAdjustBoxPositions(tvIndex);
                     }, 150);
                 }
                 return;
             }
            tvState.boxes.forEach(box => {
                box.x = Math.max(0, Math.min(box.x ?? tvState.screenWidth/2, tvState.screenWidth - tvState.dynamicBoxWidth));
                box.y = Math.max(0, Math.min(box.y ?? tvState.screenHeight/2, tvState.screenHeight - tvState.dynamicBoxHeight));
                if (box.element) {
                    box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                } else {
                    box.element = createBoxElement(tvState, box);
                }
            });
        }

        // --- Update Loop ---
        function gameLoop(timestamp) {
            if (document.hidden) { return; }

            if (!lastTimestamp) { lastTimestamp = timestamp; return; }
            const deltaTime = Math.min(0.1, (timestamp - lastTimestamp) / 1000);
            lastTimestamp = timestamp;

            globalState.tvStates.forEach((tvState, tvIndex) => {
                 if (!tvState.screenWidth || tvState.screenWidth <= 0) {
                    resizeTvScreen(tvState);
                 } else {
                    updateSingleTv(tvState, tvIndex, deltaTime, timestamp);
                 }
             });

            updateTotalHitsDisplay();
            updateAllTvGlows();
            checkMetaButtonVisibility();

            if (upgradeModal.classList.contains('show')) {
                hitsThresholdCache = {}; // Clear threshold cache at the start of the update relevant to the modal
                if (selectedTvIndex !== -1) {
                    const tvState = globalState.tvStates[selectedTvIndex];
                    if (tvState) updateModalTvStats(tvState);
                    updateSelectedTvUpgradeButtons();
                } else {
                    modalTvStats.textContent = `Static Charges: ${formatScore(globalState.systemStaticCharges)}`;
                    updateMetaUpgradeButtonsIfVisible();
                    updateRebootPreviewIfVisible(); // This now includes progress bar update
                }
            }

            const now = Date.now();
            if (now - lastSaveTime > 5000) {
                saveGame();
                lastSaveTime = now;
            }
        }

        function updateSingleTv(tvState, tvIndex, deltaTime, timestamp) {
             if (!tvState.screenWidth || !tvState.screenHeight || !tvState.dynamicBoxWidth || !tvState.dynamicBoxHeight || tvState.screenWidth <= 0 || tvState.screenHeight <= 0) {
                 return;
             }
            const screenWidth = tvState.screenWidth;
            const screenHeight = tvState.screenHeight;
            const effectiveBoxWidth = tvState.dynamicBoxWidth;
            const effectiveBoxHeight = tvState.dynamicBoxHeight;
            const currentSpeed = getCurrentTvSpeed(tvState);
            let cornerHitData = [];
            let boxCollisionsThisFrame = [];
            let wallHitData = [];

            tvState.boxes.forEach(box => {
                 if (!box.element) {
                     box.element = createBoxElement(tvState, box);
                     if(!box.element) return;
                     box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                  }

                if (isNaN(box.vx) || isNaN(box.vy)) { box.vx = (Math.random()-0.5)*currentSpeed*0.5; box.vy = (Math.random()-0.5)*currentSpeed*0.5; };
                let boxVX = box.vx; let boxVY = box.vy;
                const speedMagnitude = Math.sqrt(boxVX**2 + boxVY**2);
                if (speedMagnitude > 0.01 && Math.abs(speedMagnitude - currentSpeed) > 0.1 * currentSpeed) {
                    const sf = currentSpeed/speedMagnitude;
                    boxVX*=(isNaN(sf)?1:sf); boxVY*=(isNaN(sf)?1:sf);
                } else if (speedMagnitude < 0.1*currentSpeed && currentSpeed > 0.1) {
                    const a = Math.random()*Math.PI*2;
                    boxVX=Math.cos(a)*currentSpeed*0.5; boxVY=Math.sin(a)*currentSpeed*0.5;
                }

                let deltaX = boxVX * deltaTime * 60;
                let deltaY = boxVY * deltaTime * 60;
                deltaX = Math.max(-effectiveBoxWidth*0.8,Math.min(effectiveBoxWidth*0.8,deltaX));
                deltaY = Math.max(-effectiveBoxHeight*0.8,Math.min(effectiveBoxHeight*0.8,deltaY));
                box.x += deltaX;
                box.y += deltaY;

                let hitWall=false; let hitX=false, hitY=false; let hitSide = '';
                if (box.x <= 0 && boxVX < 0) { box.x = 0+Math.random()*0.1; boxVX = Math.abs(boxVX); hitWall=true; hitX=true; hitSide='left';}
                else if (box.x >= screenWidth-effectiveBoxWidth && boxVX > 0) { box.x = screenWidth-effectiveBoxWidth-Math.random()*0.1; boxVX = -Math.abs(boxVX); hitWall=true; hitX=true; hitSide='right';}
                if (box.y <= 0 && boxVY < 0) { box.y = 0+Math.random()*0.1; boxVY = Math.abs(boxVY); hitWall=true; hitY=true; hitSide='top';}
                else if (box.y >= screenHeight-effectiveBoxHeight && boxVY > 0) { box.y = screenHeight-effectiveBoxHeight-Math.random()*0.1; boxVY = -Math.abs(boxVY); hitWall=true; hitY=true; hitSide='bottom';}

                if (hitWall) {
                    if (box.element) box.element.style.backgroundColor = getRandomColor();
                    const cornerThreshold = Math.min(1.5, effectiveBoxWidth * 0.03, effectiveBoxHeight * 0.03);
                    const isNearLeft = box.x <= cornerThreshold;
                    const isNearRight = box.x >= screenWidth-effectiveBoxWidth-cornerThreshold;
                    const isNearTop = box.y <= cornerThreshold;
                    const isNearBottom = box.y >= screenHeight-effectiveBoxHeight-cornerThreshold;
                    const isCorner = (isNearLeft || isNearRight) && (isNearTop || isNearBottom);

                    if (isCorner && hitX && hitY) {
                        tvState.lastCornerHitTimestamp = Date.now();

                        let cornerX = isNearLeft ? 0 : screenWidth;
                        let cornerY = isNearTop ? 0 : screenHeight;
                        const escapeFactor = 1.08;
                        if (isNearLeft) boxVX=Math.abs(boxVX)*escapeFactor; else boxVX=-Math.abs(boxVX)*escapeFactor;
                        if (isNearTop) boxVY=Math.abs(boxVY)*escapeFactor; else boxVY=-Math.abs(boxVY)*escapeFactor;

                        const finalCornerBonus = Math.ceil(tvState.cornerHitBaseBonus * tvState.cornerHitMultiplier * globalState.synergyBonus * devSpeedFactor);
                        addTvHitScore(finalCornerBonus);

                        cornerHitData.push({ x: cornerX, y: cornerY, boxId: box.id, bonusAmount: finalCornerBonus });
                    }
                    else {
                        let baseWallHitAmount = tvState.hitValue;

                        const cornersSuckLevel = globalState.metaLevels.cornersSuckBonus;
                        let cornersSuckMultiplier = 1.0;
                        if (cornersSuckLevel > 0 && tvState.lastCornerHitTimestamp) {
                            const elapsedMs = Date.now() - tvState.lastCornerHitTimestamp;
                            const bonusRatio = Math.min(
                                CORNERS_SUCK_MAX_MULTIPLIER - 1,
                                (elapsedMs / CORNERS_SUCK_TIME_SCALE_FACTOR) * (cornersSuckLevel * CORNERS_SUCK_LEVEL_SCALE_FACTOR)
                            );
                            cornersSuckMultiplier = 1 + bonusRatio;
                            baseWallHitAmount *= cornersSuckMultiplier;
                        }
                        const finalWallHitAmount = Math.ceil(baseWallHitAmount * globalState.synergyBonus * devSpeedFactor);
                        addTvHitScore(finalWallHitAmount);

                        let popupX = box.x + effectiveBoxWidth / 2;
                        let popupY = box.y + effectiveBoxHeight / 2;
                        if (hitSide === 'left') popupX = effectiveBoxWidth * 0.5; else if (hitSide === 'right') popupX = screenWidth - effectiveBoxWidth * 0.5;
                        if (hitSide === 'top') popupY = effectiveBoxHeight * 0.5; else if (hitSide === 'bottom') popupY = screenHeight - effectiveBoxHeight * 0.5;

                        wallHitData.push({ x: popupX, y: popupY, amount: finalWallHitAmount });
                    }
                }
                box.vx = boxVX; box.vy = boxVY;
                box.x = Math.max(0, Math.min(box.x, screenWidth - effectiveBoxWidth));
                box.y = Math.max(0, Math.min(box.y, screenHeight - effectiveBoxHeight));
            });

            // Box-on-box collision
            for (let i = 0; i < tvState.boxes.length; i++) {
                 if (!tvState.boxes[i].element) continue;
                 for (let j = i + 1; j < tvState.boxes.length; j++) {
                    if (!tvState.boxes[j].element) continue;

                    const b1 = tvState.boxes[i]; const b2 = tvState.boxes[j];
                    const b1CenterX = b1.x + effectiveBoxWidth / 2; const b1CenterY = b1.y + effectiveBoxHeight / 2;
                    const b2CenterX = b2.x + effectiveBoxWidth / 2; const b2CenterY = b2.y + effectiveBoxHeight / 2;
                    const dx = b2CenterX - b1CenterX; const dy = b2CenterY - b1CenterY;
                    const overlapX = effectiveBoxWidth - Math.abs(dx);
                    const overlapY = effectiveBoxHeight - Math.abs(dy);

                    if (overlapX > 0 && overlapY > 0) {
                        const collisionKey = getBoxCollisionKey(b1.id, b2.id);
                        const lastCollisionTime = boxCollisionTimers[collisionKey] || 0;
                        if (timestamp - lastCollisionTime < BOX_COLLISION_COOLDOWN_MS) continue;
                        boxCollisionTimers[collisionKey] = timestamp;

                        if (overlapX < overlapY) {
                            const separationAmount = overlapX * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dx < 0 ? -1 : 1;
                            b1.x -= separationAmount * sign; b2.x += separationAmount * sign;
                            const v1x = b1.vx; b1.vx = b2.vx * COLLISION_ENERGY_LOSS; b2.vx = v1x * COLLISION_ENERGY_LOSS;
                        } else {
                            const separationAmount = overlapY * 0.5 + BOX_COLLISION_SEPARATION_BUFFER; const sign = dy < 0 ? -1 : 1;
                            b1.y -= separationAmount * sign; b2.y += separationAmount * sign;
                            const v1y = b1.vy; b1.vy = b2.vy * COLLISION_ENERGY_LOSS; b2.vy = v1y * COLLISION_ENERGY_LOSS;
                        }
                        b1.x = Math.max(0, Math.min(b1.x, screenWidth - effectiveBoxWidth)); b1.y = Math.max(0, Math.min(b1.y, screenHeight - effectiveBoxHeight));
                        b2.x = Math.max(0, Math.min(b2.x, screenWidth - effectiveBoxWidth)); b2.y = Math.max(0, Math.min(b2.y, screenHeight - effectiveBoxHeight));

                        boxCollisionsThisFrame.push({ b1Id: b1.id, b2Id: b2.id, x: b1CenterX + dx / 2, y: b1CenterY + dy / 2 });
                    }
                }
            }

            // Process Hit Effects
            if (wallHitData.length > 0) {
                 wallHitData.forEach(hit => {
                    showFloatText(tvState, `+${formatScore(hit.amount)}`, hit.x, hit.y, 'wall');
                 });
            }
            if (cornerHitData.length > 0) {
                cornerHitData.forEach(hit => {
                    createSparkParticles(tvState, hit.x, hit.y);
                    showFloatText(tvState, `CORNER HIT!\n+${formatScore(hit.bonusAmount)}`, tvState.screenWidth/2, tvState.screenHeight/2, 'corner');
                });
            }
            if (boxCollisionsThisFrame.length > 0) {
                let collisionValue = tvState.boxCollisionValue;
                let finalCollisionValue = Math.ceil(collisionValue * globalState.synergyBonus * devSpeedFactor);
                let totalCollisionBonus = boxCollisionsThisFrame.length * finalCollisionValue;
                addTvHitScore(totalCollisionBonus);
                boxCollisionsThisFrame.forEach(hit => {
                    showFloatText(tvState, `+${formatScore(finalCollisionValue)}`, hit.x, hit.y, 'collision');
                });
            }

            // Update Element Positions
            tvState.boxes.forEach(box => {
                if (box.element) {
                     box.element.style.transform = `translate(${box.x}px, ${box.y}px)`;
                }
            });
        }

        // --- Scoring & Stats ---
        function addTvHitScore(finalAmount) {
            if (finalAmount <= 0 || isNaN(finalAmount)) return;
            const effectiveGain = Math.ceil(finalAmount);
            if (effectiveGain <= 0) return;

            globalState.totalSessionHits += effectiveGain;
            globalState.lifetimeSessionHits += effectiveGain;
        }
        function updateModalTvStats(tvState) { if (!modalTvStats || !tvState) return; const currentMaxBoxes = globalState.maxBoxesPerTv; modalTvStats.textContent = `TV #${tvState.id} | Logos: ${tvState.boxes.length}/${currentMaxBoxes}`; }
        function updateTotalHitsDisplay() { if (totalHitsDisplay) { totalHitsDisplay.textContent = `Hits: ${formatScore(globalState.totalSessionHits)}`; } }

        // --- Effects & Feedback ---
        function createSparkParticles(tvState, cornerX, cornerY) { if (!tvState.elements || !tvState.elements.screen) return; const screenElement = tvState.elements.screen; const particleCount = 12; const particleLifespan = 650; const particleSpread = tvState.screenWidth * 0.18; for (let i = 0; i < particleCount; i++) { const p = document.createElement('div'); p.classList.add('spark-particle'); p.style.left = `${cornerX}px`; p.style.top = `${cornerY}px`; screenElement.appendChild(p); const ang = Math.random()*Math.PI*2; const dist = Math.random()*particleSpread; let dX=Math.cos(ang); let dY=Math.sin(ang); if(cornerX<tvState.screenWidth/2) dX=Math.abs(dX); else dX=-Math.abs(dX); if(cornerY<tvState.screenHeight/2) dY=Math.abs(dY); else dY=-Math.abs(dY); const tX=dX*dist; const tY=dY*dist; requestAnimationFrame(()=>{p.style.transform=`translate(${tX}px, ${tY}px) scale(0.5)`; p.style.opacity=0; }); setTimeout(()=>{ p.remove(); }, particleLifespan); } }
        function showNotification(message) { if (!notificationElement) return; notificationElement.textContent = message; notificationElement.className = 'show'; if (notificationElement.timer) clearTimeout(notificationElement.timer); notificationElement.timer = setTimeout(() => { notificationElement.className = ''; notificationElement.timer = null; }, 2800); }
        function showFloatText(tvState, text, x, y, type = 'corner' | 'collision' | 'wall') { if (!tvState.elements || !tvState.elements.screen) return; const screenElement = tvState.elements.screen; const textElement = document.createElement('div'); textElement.classList.add('float-text'); let textClass = ''; let duration = 1000; switch(type) { case 'corner': textClass = 'corner-hit-text'; duration = 1300; break; case 'collision': textClass = 'collision-text'; duration = 900; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break; case 'wall': textClass = 'wall-hit-text'; duration = 800; textElement.style.left = `${x}px`; textElement.style.top = `${y}px`; break; default: return; } textElement.classList.add(textClass); textElement.textContent = text; screenElement.appendChild(textElement); setTimeout(() => { if (textElement.parentNode) textElement.remove(); }, duration); }

        // --- Glow Logic (Controls Power Light) ---
        function checkTvAffordability(tvState) {
             if (!tvState) return false;
             const currentHits = globalState.totalSessionHits;
             for (const upgrade of tvUpgrades) {
                 const level = upgrade.getLevel(tvState);
                 let maxLevel;
                 if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv;
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(tvState);
                 else maxLevel = upgrade.maxLevel;
                 const isMaxLevel = (maxLevel !== undefined && level >= maxLevel);
                 if (isMaxLevel) continue;

                 let canPurchaseCheck = typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, level) : true;
                 if (!canPurchaseCheck) continue;

                 const cost = calculateCost(upgrade.baseCost, level, upgrade.costFactor, tvState.index);
                 if (currentHits >= cost) {
                     return true;
                 }
             }
             return false;
        }
        function updateTvGlow(tvIndex) {
            const tvState = globalState.tvStates[tvIndex];
            if (tvState && tvState.elements && tvState.elements.frame) {
                const frame = tvState.elements.frame;
                const canAfford = checkTvAffordability(tvState);
                frame.classList.toggle('can-upgrade-glow', canAfford);
            }
        }
        function updateAllTvGlows() {
             globalState.tvStates.forEach((tv, index) => updateTvGlow(index));
        }

        // --- Upgrade Definitions ---
        const tvUpgrades = [
             { id: 'hitValue', name: 'Hit Value', baseCost: 10, costFactor: 1.45, getLevel: (tv) => tv.upgrades.hitValue, applyEffect: (tv) => { tv.upgrades.hitValue++; },
               getDescription: (tv, l) => `<strong>More Hits Per Hit</strong><br>Lv ${l}: +Base Hit Value` },
             { id: 'speed', name: 'Speed', baseCost: 40, costFactor: 1.65, maxLevel: 25, getLevel: (tv) => tv.upgrades.speed, applyEffect: (tv) => { tv.upgrades.speed++; },
               getDescription: (tv, l, maxed) => `<strong>Gotta Go Fast</strong><br>${maxed ? `Max Speed (Lv ${l})` : `Lv ${l}: +Logo Speed`}` },
             { id: 'cornerBonusFlat', name: 'Corner Flat Bonus', baseCost: 250, costFactor: 1.75, getLevel: (tv) => tv.upgrades.cornerBonusFlat, applyEffect: (tv) => { tv.upgrades.cornerBonusFlat++; },
               getDescription: (tv, l) => `<strong>Big Corner Bonus</strong><br>Lv ${l}: +${formatScore(deriveTvCornerFlatBonus(tv,l+1) - tv.cornerHitBaseBonus)} Base Hits` },
             { id: 'cornerMultiplier', name: 'Corner Multiplier', baseCost: 2000, costFactor: 2.3, getLevel: (tv) => tv.upgrades.cornerMultiplier, applyEffect: (tv) => { tv.upgrades.cornerMultiplier++; },
               getDescription: (tv, l) => { const currentMult = deriveTvCornerMultiplier(tv, l); const nextMult = deriveTvCornerMultiplier(tv, l+1); return `<strong>Corner Multiplier</strong><br>Lv ${l}: x${currentMult.toFixed(2)} Corner Bonus<br>(Next: x${nextMult.toFixed(2)})`; } },
             { id: 'multiBox', name: 'Add Logo', baseCost: 300, costFactor: 3.5,
                getMaxLevel: (tv) => globalState.maxBoxesPerTv, getLevel: (tv) => tv.boxes.length,
                applyEffect: (tv, tvIndex, count = 1) => { let added = 0; for (let i = 0; i < count; i++) { if(addBoxToTv(tvIndex)) added++; else break; } if (added < count && count > 1 && tv.boxes.length >= globalState.maxBoxesPerTv) showNotification("Max logos reached!"); return added > 0; },
                canPurchase: (tv, levelToCheck) => (levelToCheck ?? tv.boxes.length) < globalState.maxBoxesPerTv,
                getDescription: (tv, l, maxed) => `<strong>More Logos!</strong><br>${maxed ? `Max Logos (${tv.boxes.length})` : `Add Logo (${l+1}/${globalState.maxBoxesPerTv})`}` },
             { id: 'boxCollisionValue', name: 'Collision Hits', baseCost: 1000, costFactor: 1.55, getLevel: (tv) => tv.upgrades.boxCollisionValue, applyEffect: (tv) => { tv.upgrades.boxCollisionValue++; },
               getDescription: (tv, l) => `<strong>Bumper Logos</strong><br>Lv ${l}: +Collision Hits between Logos` },
        ];
        const metaUpgrades = [
             { id: 'metaStaticChargeGain', name: 'Static Charge Gain', baseCost: 3, costFactor: 2.2, getLevel: () => globalState.metaLevels.staticChargeGain, applyEffect: () => { globalState.metaLevels.staticChargeGain++; },
               getDescription: (gs, l, c) => `<strong>Static Charge Boost</strong><br>Lv ${l}: +${((deriveMetaStaticChargeMult(l+1)-1)*100).toFixed(0)}% Static Charges<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaAddTv', name: 'Add New TV', baseCost: 5, costFactor: 4.5, getLevel: () => globalState.tvStates.length, applyEffect: () => { addTv(); }, canPurchase: () => true,
               getDescription: (gs, l, c) => `<strong>New Channel</strong><br>Unlock TV #${l+1}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaBaseSpeed', name: 'Base Speed', baseCost: 10, costFactor: 2.8, maxLevel: 15, getLevel: () => globalState.metaLevels.baseSpeed, applyEffect: () => { globalState.metaLevels.baseSpeed++; updateAllTvsPostMeta(); },
               getDescription: (gs, l, c, maxed) => `<strong>System Speed</strong><br>${maxed ? `Max Base Speed (Lv ${l})` : `Lv ${l}: +Base Speed All TVs`}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaBaseMaxBoxes', name: 'Global Capacity', baseCost: 15, costFactor: 3.5, maxLevel: MAX_BOXES_PER_TV,
                getLevel: () => globalState.metaLevels.baseMaxBoxes, applyEffect: () => { globalState.metaLevels.baseMaxBoxes++; updateAllTvsPostMeta(); updateMetaUpgradeButtonsIfVisible(); updateSelectedTvUpgradeButtons(); },
                getDescription: (gs, l, c, maxed) => `<strong>More Room</strong><br>${maxed ? `Max Global Cap (${gs.maxBoxesPerTv})` : `Lv ${l}: +Global Max Logos (${deriveMetaBaseMaxBoxes(l+1)})`}<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>` },
             { id: 'metaTvSynergyBonus', name: 'TV Synergy', baseCost: 50, costFactor: 2.5, getLevel: () => globalState.metaLevels.tvSynergyBonus, applyEffect: () => { globalState.metaLevels.tvSynergyBonus++; recalculateGlobalSynergy(); updateMetaUpgradeButtonsIfVisible(); },
               getDescription: (gs, l, c) => { const nextLevel = l + 1; const nextPerTvBonus = deriveSynergyBonusPerTv(nextLevel); return `<strong>Teamwork!</strong><br>Lv ${l}: All Hits x${globalState.synergyBonus.toFixed(3)}<br>(+${(nextPerTvBonus*100).toFixed(2)}% per TV Next)<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>`; } },
             { id: 'metaCornersSuck', name: 'Corners Suck', baseCost: 100, costFactor: 2.9,
               getLevel: () => globalState.metaLevels.cornersSuckBonus,
               applyEffect: () => { globalState.metaLevels.cornersSuckBonus++; },
               getDescription: (gs, l, c) => { const maxBonusPercent = (CORNERS_SUCK_MAX_MULTIPLIER - 1) * 100; return `<strong>Corners Suck</strong><br>Lv ${l}: +Wall hits value over time (Max +${maxBonusPercent.toFixed(0)}%)<br>Resets on TV corner hit<br>Cost: <span class="upgrade-cost meta">${formatScore(c)}</span>`; }
             },
        ];

        // --- Upgrade Calculation Functions ---
        function deriveTvHitValue(tvState, level) { return Math.max(1, Math.ceil(1 + level * 1.5)); }
        function deriveTvSpeedFactor(tvState, level) { return Math.min(3.0, (1 + level * 0.04) * tvState.baseSpeedFactorMeta); }
        function deriveTvCornerFlatBonus(tvState, level) { return Math.max(0, Math.floor(2000 + level * 10 + Math.pow(level, 1.55) * 50)); }
        function deriveTvCornerMultiplier(tvState, level) { return 1.0 + level * 0.10; }
        function deriveTvCollisionBonus(tvState, level) { return Math.max(0, Math.floor(2 + level * 0.5 + Math.pow(level, 1.2))); }
        function getCurrentTvSpeed(tvState) { return BASE_SPEED_CONSTANT * deriveTvSpeedFactor(tvState, tvState.upgrades.speed); }
        function deriveMetaStaticChargeMult(level) { return 1 + level * 0.07; }
        function deriveMetaBaseSpeedFactor(level) { return 1 + level * 0.03; }
        function deriveMetaBaseMaxBoxes(level) { return 2 + level; }
        function deriveSynergyBonusPerTv(level) { return level > 0 ? (level * 0.005) : 0; }
        function deriveSynergyBonus(level) { const perTvBonus = deriveSynergyBonusPerTv(level); const numTvs = globalState?.tvStates?.length ?? 0; return 1.0 + (numTvs * perTvBonus); }

        // --- Apply Upgrades ---
        function recalculateDerivedTvState(tvState) {
            tvState.hitValue = deriveTvHitValue(tvState, tvState.upgrades.hitValue);
            tvState.cornerHitBaseBonus = deriveTvCornerFlatBonus(tvState, tvState.upgrades.cornerBonusFlat);
            tvState.cornerHitMultiplier = deriveTvCornerMultiplier(tvState, tvState.upgrades.cornerMultiplier);
            tvState.boxCollisionValue = deriveTvCollisionBonus(tvState, tvState.upgrades.boxCollisionValue);
        }
        function recalculateGlobalSynergy() { globalState.synergyBonus = deriveSynergyBonus(globalState.metaLevels.tvSynergyBonus); }
        function applyMetaUpgradesToTv(tvState) { tvState.baseSpeedFactorMeta = deriveMetaBaseSpeedFactor(globalState.metaLevels.baseSpeed); recalculateDerivedTvState(tvState); resizeTvScreen(tvState); }
        function updateAllTvsPostMeta() { globalState.maxBoxesPerTv = deriveMetaBaseMaxBoxes(globalState.metaLevels.baseMaxBoxes); globalState.tvStates.forEach(tv => { applyMetaUpgradesToTv(tv); checkAndAdjustBoxPositions(tv.index); }); recalculateGlobalSynergy(); updateAllTvGlows(); }

        // --- Upgrade UI & Modal Logic ---
        function openUpgradeModal(tvIndex = -1) {
            selectedTvIndex = tvIndex; modalUpgradesContainer.innerHTML = ''; modalRebootContainer.innerHTML = ''; modalBuyAmountContainer.innerHTML = '';

            if (tvIndex !== -1) {
                const tvState = globalState.tvStates[tvIndex]; if (!tvState) return;
                modalTitle.textContent = `TV #${tvState.id} Upgrades`;
                updateModalTvStats(tvState);
                renderBuyAmountButtons();
                renderUpgradeSection(tvUpgrades, modalUpgradesContainer, 'hit', tvIndex);
            } else {
                modalTitle.textContent = 'Meta Upgrades & Reboot';
                modalTvStats.textContent = `Static Charges: ${formatScore(globalState.systemStaticCharges)}`;
                renderUpgradeSection(metaUpgrades, modalUpgradesContainer, 'meta');
                const potentialGain = calculateStaticChargeGain(globalState.lifetimeSessionHits);
                if (potentialGain > 0 || globalState.hasRebootedOnce) {
                    const rebootTemplate = document.getElementById('reboot-section-template');
                    if (rebootTemplate) {
                        const clonedReboot = rebootTemplate.firstElementChild.cloneNode(true);
                        const rebootBtn = clonedReboot.querySelector('#reboot-button');
                        if (rebootBtn) { rebootBtn.onclick = executeReboot; }
                        modalRebootContainer.appendChild(clonedReboot);
                        hitsThresholdCache = {}; // Clear cache before first calculation
                        updateRebootPreviewIfVisible(); // Includes progress bar update
                    } else { console.error("Reboot template not found!"); }
                }
            }
            upgradeModal.classList.add('show');
        }
        function closeUpgradeModal() { upgradeModal.classList.remove('show'); selectedTvIndex = -1; updateAllTvGlows(); }
        function renderBuyAmountButtons() {
            modalBuyAmountContainer.innerHTML = ''; const amounts = [1, 10, 100, 'max'];
            amounts.forEach(amount => {
                const btn = document.createElement('button'); btn.classList.add('buy-amount-button'); btn.textContent = `${amount === 'max' ? 'Max' : 'x'+amount}`; btn.dataset.amount = amount;
                if (selectedBuyAmount === amount || (selectedBuyAmount === Infinity && amount === 'max')) { btn.classList.add('active'); }
                btn.onclick = () => setBuyAmount(amount); modalBuyAmountContainer.appendChild(btn);
            });
        }
        function setBuyAmount(amount) {
            selectedBuyAmount = (amount === 'max') ? Infinity : parseInt(amount);
            globalState.selectedBuyAmount = (amount === 'max') ? 'max' : selectedBuyAmount;
            const buttons = modalBuyAmountContainer.querySelectorAll('.buy-amount-button');
            buttons.forEach(btn => { const btnAmount = btn.dataset.amount; const isActive = (selectedBuyAmount === Infinity && btnAmount === 'max') || (selectedBuyAmount === parseInt(btnAmount)); btn.classList.toggle('active', isActive); });
            updateSelectedTvUpgradeButtons();
        }

        function calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex) {
            const amountToTry = selectedBuyAmount;
            const currentLevel = upgrade.getLevel(tvState);
            let totalCost = 0; let levelsBought = 0; let maxLevelReached = false;
            let nextLevelCost = 0;

            let maxLevel;
            if (upgrade.id === 'multiBox') maxLevel = globalState.maxBoxesPerTv;
            else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(tvState);
            else maxLevel = upgrade.maxLevel;

            const isCurrentlyMaxed = (maxLevel !== undefined && currentLevel >= maxLevel) || !(typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, currentLevel) : true);

            if (isCurrentlyMaxed) {
                return { levels: 0, totalCost: 0, affordable: false, isMaxLevel: true, nextLevelCost: 0 };
            }

            nextLevelCost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor, tvIndex);

            const maxIterations = (amountToTry === Infinity) ? MAX_BULK_BUY_CHECK : amountToTry;
            const flooredScore = Math.floor(currentScore);

            for (let i = 0; i < maxIterations; i++) {
                const levelToCheck = currentLevel + levelsBought;

                if (maxLevel !== undefined && levelToCheck >= maxLevel) { maxLevelReached = true; break; }
                if (!(typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(tvState, levelToCheck) : true)) { maxLevelReached = true; break; }

                const costForThisLevel = calculateCost(upgrade.baseCost, levelToCheck, upgrade.costFactor, tvIndex);
                if (flooredScore >= totalCost + costForThisLevel) {
                    totalCost += costForThisLevel;
                    levelsBought++;
                } else {
                    break;
                }
            }

            const affordable = levelsBought > 0;

            return {
                levels: levelsBought,
                totalCost: totalCost,
                affordable: affordable,
                isMaxLevel: isCurrentlyMaxed || (maxLevelReached && levelsBought === 0),
                nextLevelCost: nextLevelCost
            };
        }

        function renderUpgradeSection(upgrades, container, currencyType, tvIndex = -1) {
             if (!container) return; container.innerHTML = '';
             const isTvModal = currencyType === 'hit' && tvIndex !== -1;
             const tvState = isTvModal ? globalState.tvStates[tvIndex] : null;
             const stateForLevel = tvState ?? globalState;
             const currentScore = currencyType === 'hit' ? globalState.totalSessionHits : globalState.systemStaticCharges;

             upgrades.forEach(upgrade => {
                 const currentLevel = upgrade.getLevel(stateForLevel);
                 let bulkInfo = { levels: 1, totalCost: 0, affordable: false, isMaxLevel: false, nextLevelCost: 0 };
                 let descriptionText = ''; let currencyClass = currencyType;
                 let costToShow = 0;
                 let levelText = '';
                 let isCurrentlyMaxed = false;

                 let maxLevelCheck;
                 if (upgrade.id === 'multiBox' && tvState) maxLevelCheck = globalState.maxBoxesPerTv;
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevelCheck = upgrade.getMaxLevel(stateForLevel);
                 else maxLevelCheck = upgrade.maxLevel;

                 isCurrentlyMaxed = (maxLevelCheck !== undefined && currentLevel >= maxLevelCheck);
                 if (!isCurrentlyMaxed && typeof upgrade.canPurchase === 'function') {
                     isCurrentlyMaxed = !upgrade.canPurchase(stateForLevel, currentLevel);
                 }

                 if (isTvModal && tvState) {
                     bulkInfo = calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex);
                     isCurrentlyMaxed = bulkInfo.isMaxLevel;
                     descriptionText = upgrade.getDescription(tvState, currentLevel, isCurrentlyMaxed);
                     if (!isCurrentlyMaxed) {
                         if (bulkInfo.affordable && bulkInfo.levels > 0) {
                             costToShow = bulkInfo.totalCost;
                             if (bulkInfo.levels > 1) levelText = ` (x${bulkInfo.levels})`;
                         } else {
                             costToShow = bulkInfo.nextLevelCost;
                         }
                     }
                 } else {
                     const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor);
                     costToShow = cost;
                     bulkInfo.affordable = currentScore >= cost && !isCurrentlyMaxed;
                     bulkInfo.isMaxLevel = isCurrentlyMaxed;
                     descriptionText = upgrade.getDescription(globalState, currentLevel, cost, isCurrentlyMaxed);
                 }

                 const btn = document.createElement('button');
                 btn.classList.add('upgrade-button');
                 btn.dataset.upgradeId = upgrade.id;
                 btn.dataset.currencyType = currencyType;
                 if (tvIndex >= 0) btn.dataset.tvIndex = tvIndex;

                 btn.innerHTML = `<div class="upgrade-description">${descriptionText}</div>`;
                 if (!isCurrentlyMaxed && currencyType === 'hit') {
                     btn.innerHTML += `<div class="upgrade-cost ${currencyClass}">Cost: ${formatScore(costToShow)}${levelText}</div>`;
                 } else if (isCurrentlyMaxed && currencyType === 'hit') {
                     // Optional: Indicate Maxed
                 }

                 btn.disabled = isCurrentlyMaxed || !bulkInfo.affordable;
                 btn.onclick = () => buyUpgrade(upgrade.id, currencyType, tvIndex);
                 container.appendChild(btn);
             });
        }


        function updateUpgradeButtonsInSection(upgrades, container, currencyType, tvIndex = -1) {
            if (!container) return;
            const isTvModal = currencyType === 'hit' && tvIndex !== -1;
            const tvState = isTvModal ? globalState.tvStates[tvIndex] : null;
            const stateForLevel = tvState ?? globalState;
            const currentScore = currencyType === 'hit' ? globalState.totalSessionHits : globalState.systemStaticCharges;

            upgrades.forEach(upgrade => {
                const btn = container.querySelector(`[data-upgrade-id="${upgrade.id}"]`);
                if (btn) {
                    const currentLevel = upgrade.getLevel(stateForLevel);
                    let bulkInfo = { levels: 1, totalCost: 0, affordable: false, isMaxLevel: false, nextLevelCost: 0 };
                    let descriptionText = ''; let currencyClass = currencyType;
                    let costToShow = 0;
                    let levelText = '';
                    let isCurrentlyMaxed = false;

                    let maxLevelCheck;
                    if (upgrade.id === 'multiBox' && tvState) maxLevelCheck = globalState.maxBoxesPerTv;
                    else if (typeof upgrade.getMaxLevel === 'function') maxLevelCheck = upgrade.getMaxLevel(stateForLevel);
                    else maxLevelCheck = upgrade.maxLevel;

                    isCurrentlyMaxed = (maxLevelCheck !== undefined && currentLevel >= maxLevelCheck);
                     if (!isCurrentlyMaxed && typeof upgrade.canPurchase === 'function') {
                        isCurrentlyMaxed = !upgrade.canPurchase(stateForLevel, currentLevel);
                     }

                    const descDiv = btn.querySelector('.upgrade-description');
                    let costDiv = btn.querySelector('.upgrade-cost');

                    if (isTvModal && tvState) {
                        bulkInfo = calculateBulkCostAndLevels(upgrade, tvState, currentScore, tvIndex);
                        isCurrentlyMaxed = bulkInfo.isMaxLevel;
                        descriptionText = upgrade.getDescription(tvState, currentLevel, isCurrentlyMaxed);
                        if (descDiv) descDiv.innerHTML = descriptionText;

                        if (!isCurrentlyMaxed) {
                            if (bulkInfo.affordable && bulkInfo.levels > 0) {
                                costToShow = bulkInfo.totalCost;
                                if (bulkInfo.levels > 1) levelText = ` (x${bulkInfo.levels})`;
                            } else {
                                costToShow = bulkInfo.nextLevelCost;
                            }
                            if (!costDiv) {
                                costDiv = document.createElement('div');
                                costDiv.classList.add('upgrade-cost', currencyClass);
                                btn.appendChild(costDiv);
                            }
                            costDiv.innerHTML = `Cost: ${formatScore(costToShow)}${levelText}`;
                            costDiv.style.display = '';
                        } else {
                             if (costDiv) costDiv.style.display = 'none';
                        }

                    } else {
                        const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor);
                        costToShow = cost;
                        bulkInfo.affordable = currentScore >= cost && !isCurrentlyMaxed;
                        bulkInfo.isMaxLevel = isCurrentlyMaxed;
                        descriptionText = upgrade.getDescription(globalState, currentLevel, cost, isCurrentlyMaxed);
                        if (descDiv) descDiv.innerHTML = descriptionText;
                        if (costDiv && currencyType === 'meta') {
                            costDiv.style.display = 'none';
                        }
                    }

                    btn.disabled = isCurrentlyMaxed || !bulkInfo.affordable;
                }
            });
        }


        function buyUpgrade(id, currencyType, tvIndex = -1) {
            const upgrades = currencyType === 'hit' ? tvUpgrades : metaUpgrades;
            const upgrade = upgrades.find(u => u.id === id); if (!upgrade) return;

            const isTvUpgrade = currencyType === 'hit' && tvIndex !== -1;
            const amountToTry = isTvUpgrade ? selectedBuyAmount : 1;

            const stateToModify = isTvUpgrade ? globalState.tvStates[tvIndex] : globalState;
            if (!stateToModify) { console.error("Invalid state for upgrade:", id, currencyType, tvIndex); return; }

            const scoreRef = currencyType === 'hit' ? 'totalSessionHits' : 'systemStaticCharges';
            const currentScore = globalState[scoreRef];

            let currentLevel = upgrade.getLevel(stateToModify);
            let totalCost = 0;
            let levelsToBuy = 0;

            const maxIterations = (amountToTry === Infinity) ? MAX_BULK_BUY_CHECK : amountToTry;
            const flooredScore = Math.floor(currentScore);

            for (let i = 0; i < maxIterations; i++) {
                const levelToCheck = currentLevel + levelsToBuy;

                let maxLevel;
                 if (upgrade.id === 'multiBox' && isTvUpgrade) maxLevel = globalState.maxBoxesPerTv;
                 else if (typeof upgrade.getMaxLevel === 'function') maxLevel = upgrade.getMaxLevel(stateToModify);
                 else maxLevel = upgrade.maxLevel;
                if (maxLevel !== undefined && levelToCheck >= maxLevel) break;

                if (!(typeof upgrade.canPurchase === 'function' ? upgrade.canPurchase(stateToModify, levelToCheck) : true)) break;

                const costForThisLevel = calculateCost(upgrade.baseCost, levelToCheck, upgrade.costFactor, tvIndex);

                if (flooredScore >= totalCost + costForThisLevel) {
                    totalCost += costForThisLevel;
                    levelsToBuy++;
                } else {
                    break;
                }
            }


            if (levelsToBuy > 0) {
                globalState[scoreRef] -= totalCost;

                if (isTvUpgrade) {
                    if (upgrade.id === 'multiBox') {
                        upgrade.applyEffect(stateToModify, tvIndex, levelsToBuy);
                    } else {
                         for(let k=0; k<levelsToBuy; k++) {
                             upgrade.applyEffect(stateToModify, tvIndex);
                         }
                    }
                    recalculateDerivedTvState(stateToModify);
                    updateModalTvStats(stateToModify);
                    updateSelectedTvUpgradeButtons();
                    updateTvGlow(tvIndex);
                } else {
                     upgrade.applyEffect(stateToModify, tvIndex);
                     if (upgrade.id === 'metaTvSynergyBonus' || upgrade.id === 'metaAddTv') recalculateGlobalSynergy();
                     if (upgrade.id === 'metaBaseMaxBoxes' || upgrade.id === 'metaBaseSpeed') updateAllTvsPostMeta();
                     if (upgrade.id === 'metaAddTv') checkMetaButtonVisibility();
                     if (upgrade.id === 'metaBaseMaxBoxes') {
                         updateSelectedTvUpgradeButtons();
                     }
                     modalTvStats.textContent = `Static Charges: ${formatScore(globalState.systemStaticCharges)}`;
                     hitsThresholdCache = {}; // Clear cache after meta upgrade purchase
                     updateMetaUpgradeButtonsIfVisible();
                     updateRebootPreviewIfVisible();
                     updateAllTvGlows();
                }

                updateTotalHitsDisplay();
                saveGame();
            } else {
                 const nextCost = calculateCost(upgrade.baseCost, currentLevel, upgrade.costFactor, tvIndex);
                 console.log(`Cannot afford ${amountToTry === Infinity ? 1 : amountToTry} level(s) of ${id}. Need ${formatScore(nextCost)}, have ${formatScore(currentScore)}`);
            }
        }

        // --- Button Updates ---
        function updateSelectedTvUpgradeButtons() { if (selectedTvIndex !== -1 && upgradeModal.classList.contains('show')) { updateUpgradeButtonsInSection(tvUpgrades, modalUpgradesContainer, 'hit', selectedTvIndex); } }
        function updateMetaUpgradeButtonsIfVisible() { if (selectedTvIndex === -1 && upgradeModal.classList.contains('show')) { updateUpgradeButtonsInSection(metaUpgrades, modalUpgradesContainer, 'meta'); } }

        // --- Reboot Logic ---
        function canCurrentlyReboot() { return globalState.systemStaticCharges > 0 || globalState.hasRebootedOnce || calculateStaticChargeGain(globalState.lifetimeSessionHits) > 0; }
        function checkMetaButtonVisibility() { metaMenuButton.classList.toggle('show', canCurrentlyReboot()); }

        // Finds the minimum hits needed to reach a targetGain level
        function findHitsThreshold(targetGain) {
            if (targetGain <= 0) return 0;
            // Check cache first
            if (hitsThresholdCache[targetGain] !== undefined) {
                return hitsThresholdCache[targetGain];
            }

            let lowerBound = 0;
            let upperBound = REBOOT_MIN_HITS_FOR_FIRST_CHARGE; // Start with a reasonable upper guess

            // Quickly find an upper bound
            let iterations = 0;
            while (calculateStaticChargeGain(upperBound) < targetGain && iterations < 50 && upperBound < FIND_THRESHOLD_MAX_HITS) {
                lowerBound = upperBound;
                upperBound *= 5; // Increase guess exponentially
                iterations++;
            }
            upperBound = Math.min(upperBound, FIND_THRESHOLD_MAX_HITS);

            // If upper bound is still too low (or max hits reached), return max/infinity
             if (calculateStaticChargeGain(upperBound) < targetGain || upperBound >= FIND_THRESHOLD_MAX_HITS) {
                 hitsThresholdCache[targetGain] = Infinity; // Cache infinity if target is unreachable
                 return Infinity;
             }


            // Binary search between lowerBound and upperBound
            let bestGuess = upperBound;
            iterations = 0; // Reset iteration count for binary search
            while (lowerBound <= upperBound && iterations < FIND_THRESHOLD_MAX_ITERATIONS) {
                const mid = Math.floor(lowerBound + (upperBound - lowerBound) / 2);
                if (mid <= 0) break; // Avoid infinite loop if mid becomes 0

                const gainAtMid = calculateStaticChargeGain(mid);

                if (gainAtMid >= targetGain) {
                    bestGuess = mid; // Found a potential threshold, try lower
                    upperBound = mid - 1;
                } else {
                    lowerBound = mid + 1; // Need more hits
                }
                iterations++;
            }

             if (iterations >= FIND_THRESHOLD_MAX_ITERATIONS) {
                 console.warn(`findHitsThreshold exceeded max iterations for targetGain ${targetGain}. Returning best guess: ${bestGuess}`);
             }

            hitsThresholdCache[targetGain] = bestGuess; // Cache the result
            return bestGuess;
        }


        function updateRebootPreviewIfVisible() {
            if (selectedTvIndex !== -1 || !upgradeModal.classList.contains('show')) return;
            const rebootSection = modalRebootContainer.querySelector('#reboot-section');
            if (!rebootSection) return;

            const rebootGainPreview = rebootSection.querySelector('#reboot-gain-preview');
            const rebootButton = rebootSection.querySelector('#reboot-button');
            const progressContainer = rebootSection.querySelector('#reboot-progress-container');
            const progressBar = rebootSection.querySelector('#reboot-progress-bar');
            const progressText = rebootSection.querySelector('#reboot-progress-text');

            if (!rebootGainPreview || !rebootButton || !progressContainer || !progressBar || !progressText) return;

            const currentLifetimeHits = globalState.lifetimeSessionHits;
            const totalPotentialGain = calculateStaticChargeGain(currentLifetimeHits);

            rebootGainPreview.textContent = `Gain ~${formatScore(totalPotentialGain)} Static Charges (from ${formatScore(currentLifetimeHits)} total Hits)`;
            rebootButton.disabled = totalPotentialGain <= 0;

            // --- Progress Bar Update ---
            let hitsForCurrentGain = 0;
            let hitsForNextGain = Infinity;
            let hitsRemaining = 0;
            let progressPercent = 0;
            let displayText = "";

            if (totalPotentialGain === 0) {
                // Progress towards the *first* charge
                hitsForNextGain = findHitsThreshold(1);
                if (hitsForNextGain === Infinity || hitsForNextGain <= REBOOT_MIN_HITS_FOR_FIRST_CHARGE) {
                    hitsRemaining = REBOOT_MIN_HITS_FOR_FIRST_CHARGE - currentLifetimeHits;
                    progressPercent = Math.min(100, Math.max(0, (currentLifetimeHits / REBOOT_MIN_HITS_FOR_FIRST_CHARGE) * 100));
                     displayText = `${formatScore(Math.max(0, hitsRemaining))} Hits for first charge`;
                } else {
                    hitsRemaining = hitsForNextGain - currentLifetimeHits;
                    progressPercent = Math.min(100, Math.max(0, (currentLifetimeHits / hitsForNextGain) * 100));
                     displayText = `${formatScore(Math.max(0, hitsRemaining))} Hits for first charge`;
                }
                 progressBar.style.width = `${progressPercent}%`;
                 progressText.textContent = displayText;
                 progressContainer.style.display = 'block'; // Ensure it's visible

            } else {
                // Progress towards the *next* charge (gain + 1)
                const targetGain = totalPotentialGain + 1;
                hitsForCurrentGain = findHitsThreshold(totalPotentialGain); // Find threshold for current gain level
                hitsForNextGain = findHitsThreshold(targetGain);     // Find threshold for next gain level

                if (hitsForNextGain === Infinity || hitsForNextGain <= hitsForCurrentGain) {
                    // Max gain reached or error in calculation
                    progressPercent = 100;
                    displayText = `Threshold Reached`;
                     progressBar.style.width = '100%';
                     progressText.textContent = displayText;
                     progressContainer.style.display = 'block';
                } else {
                    const hitsInRange = hitsForNextGain - hitsForCurrentGain;
                    const currentProgressInHits = currentLifetimeHits - hitsForCurrentGain;
                    hitsRemaining = hitsForNextGain - currentLifetimeHits;

                    progressPercent = Math.min(100, Math.max(0, (currentProgressInHits / hitsInRange) * 100));
                    displayText = `${formatScore(Math.max(0, hitsRemaining))} Hits for next charge`;

                     progressBar.style.width = `${progressPercent}%`;
                     progressText.textContent = displayText;
                     progressContainer.style.display = 'block';
                }
            }
        }


        function calculateStaticChargeGain(totalLifetimeHits) {
            if (totalLifetimeHits < REBOOT_MIN_HITS_FOR_FIRST_CHARGE) return 0; // Use constant
            const metaMultiplier = deriveMetaStaticChargeMult(globalState.metaLevels.staticChargeGain);
            const baseGain = Math.pow(totalLifetimeHits / REBOOT_MIN_HITS_FOR_FIRST_CHARGE, 0.45) * 1.5;
            const logBonus = Math.log10(totalLifetimeHits / REBOOT_MIN_HITS_FOR_FIRST_CHARGE + 1) * 0.5;
            const gain = Math.floor((baseGain + logBonus) * metaMultiplier);
            return Math.max(0, gain);
        }

        function executeReboot() {
             const staticChargesGained = calculateStaticChargeGain(globalState.lifetimeSessionHits);
             if (staticChargesGained <= 0 && globalState.lifetimeSessionHits < REBOOT_MIN_HITS_FOR_FIRST_CHARGE) {
                 showNotification("Not enough lifetime Hits for Static Charges");
                 return;
             }
              if (!confirm(`Reboot: Gain ${formatScore(staticChargesGained)} Static Charges?\n\nResets session Hits & TV Upgrades.\nKeeps Static Charges, Meta Upgrades & Unlocked TVs.`)) {
                 return;
             }

             closeUpgradeModal();
             showNotification(`Rebooted! +${formatScore(staticChargesGained)} Static Charges`);
             globalState.systemStaticCharges += staticChargesGained;
             globalState.hasRebootedOnce = true;
             globalState.totalSessionHits = 0;
             globalState.lifetimeSessionHits = 0;
             boxCollisionTimers = {};
             hitsThresholdCache = {}; // Clear cache on reboot
             devSpeedFactor = 1;
             if(document.getElementById('dev-speed-input')) document.getElementById('dev-speed-input').value = 1;

             globalState.tvStates.forEach((tvState, index) => {
                 Object.keys(tvState.upgrades).forEach(key => { tvState.upgrades[key] = 0; });
                 clearTvScreenBoxes(index);
                 tvState.boxes = [];
                 tvState.nextBoxId = 0;
                 tvState.lastCornerHitTimestamp = null;
                 recalculateDerivedTvState(tvState);
                 applyMetaUpgradesToTv(tvState);
                 addBoxToTv(index);
                 resizeTvScreen(tvState);
                 checkAndAdjustBoxPositions(index);
            });
             recalculateGlobalSynergy();
             updateTotalHitsDisplay();
             updateAllTvGlows();
             checkMetaButtonVisibility();
             saveGame();
         }

        // --- Saving and Loading ---
        function saveGame() {
            try {
                const now = Date.now();
                 if (document.hidden && (now - lastSaveTime < 4000)) {
                     return;
                 }
                 if (!globalState) {
                     console.warn("Attempted to save with null globalState.");
                     return;
                 }

                globalState.lastSaveTimestamp = now;
                lastSaveTime = now;

                const amountToSave = (selectedBuyAmount === Infinity) ? 'max' : selectedBuyAmount;
                const stateToSave = JSON.parse(JSON.stringify({...globalState, selectedBuyAmount: amountToSave}, (key, value) => {
                    if (key === 'elements' || key === 'element' || key === 'resizeRetryTimeout' || key === 'adjustRetryTimeout') return undefined;
                     if (['x', 'y', 'vx', 'vy'].includes(key)) {
                         return (typeof value === 'number' && !isNaN(value)) ? value : 0;
                     }
                     if (key === 'lastCornerHitTimestamp') {
                         return (typeof value === 'number' && value > 0) ? value : null;
                     }
                    return value;
                }));
                localStorage.setItem(SAVE_KEY, JSON.stringify(stateToSave));

            } catch (e) {
                console.error("Save Error:", e);
                showNotification("Save Error!");
            }
        }
        function loadGame() {
            const savedData = localStorage.getItem(SAVE_KEY);
            let needsInitialization = true;
            let offlineGains = 0;

            devSpeedFactor = 1;
            const speedInput = document.getElementById('dev-speed-input');
            if (speedInput) speedInput.value = devSpeedFactor;


            if (savedData) {
                try {
                    const loadedState = JSON.parse(savedData);
                    let hasNewCornerUpgrade = false;
                    if (Array.isArray(loadedState.tvStates) && loadedState.tvStates.length > 0 && loadedState.tvStates[0].upgrades) {
                       hasNewCornerUpgrade = loadedState.tvStates[0].upgrades.hasOwnProperty('cornerMultiplier');
                    }

                    if (typeof loadedState.systemStaticCharges === 'number' &&
                        Array.isArray(loadedState.tvStates) &&
                        loadedState.metaLevels &&
                        typeof loadedState.metaLevels.cornersSuckBonus === 'number' && // Check for a known required meta level
                        hasNewCornerUpgrade) {

                        globalState = createDefaultGlobalState();
                        globalState = deepMerge(globalState, loadedState);

                        globalState.totalSessionHits = Number(globalState.totalSessionHits) || 0;
                        globalState.lifetimeSessionHits = Number(globalState.lifetimeSessionHits) || globalState.totalSessionHits;
                        globalState.systemStaticCharges = Number(globalState.systemStaticCharges) || 0;
                        globalState.hasRebootedOnce = Boolean(globalState.hasRebootedOnce);
                        globalState.lastSaveTimestamp = Number(globalState.lastSaveTimestamp) || null;

                        Object.keys(globalState.metaLevels).forEach(key => {
                            if (globalState.metaLevels[key] === undefined) {
                                console.warn(`Meta level ${key} missing from save, initializing to 0.`);
                                globalState.metaLevels[key] = 0;
                            } else {
                                globalState.metaLevels[key] = Number(globalState.metaLevels[key]) || 0;
                            }
                         });

                        globalState.nextTvId = Math.max(globalState.nextTvId || 0, (globalState.tvStates.reduce((max, tv) => Math.max(max, tv.id ?? -1), -1) + 1));
                        if (globalState.metaLevels.hasOwnProperty('logoSize')) { delete globalState.metaLevels.logoSize; }

                        selectedBuyAmount = globalState.selectedBuyAmount || 1;
                        if (selectedBuyAmount === 'max') selectedBuyAmount = Infinity;
                        else selectedBuyAmount = parseInt(selectedBuyAmount) || 1;

                        // --- Calculate Offline Progress ---
                        if (globalState.lastSaveTimestamp && typeof globalState.lastSaveTimestamp === 'number') {
                            const currentTime = Date.now();
                            let offlineTimeMs = currentTime - globalState.lastSaveTimestamp;

                            if (offlineTimeMs < 0) {
                                console.warn("Negative offline time detected, ignoring offline progress calculation.");
                                offlineTimeMs = 0;
                            }

                            offlineTimeMs = Math.min(offlineTimeMs, MAX_OFFLINE_TIME_MS);

                            if (offlineTimeMs >= MIN_OFFLINE_TIME_MS) {
                                updateAllTvsPostMeta();
                                recalculateGlobalSynergy();

                                console.log(`Calculating offline gains for ${Math.round(offlineTimeMs / 1000)} seconds...`);
                                offlineGains = calculateIdleGains(offlineTimeMs);

                                if (offlineGains > 0) {
                                    globalState.totalSessionHits += offlineGains;
                                    globalState.lifetimeSessionHits += offlineGains;
                                    console.log(`Offline Gains: ${formatScore(offlineGains)} Hits`);
                                }
                            } else {
                                 console.log("Offline time too short for calculation:", offlineTimeMs, "ms");
                            }
                        } else {
                             console.log("No valid lastSaveTimestamp found for offline calculation.");
                        }

                        // Validate TV states
                        globalState.tvStates.forEach((tv, index) => {
                            tv.index = index;
                            tv.boxes = Array.isArray(tv.boxes) ? tv.boxes : [];
                            tv.boxes.forEach(box => {
                                box.x = (typeof box.x === 'number' && !isNaN(box.x)) ? box.x : 50;
                                box.y = (typeof box.y === 'number' && !isNaN(box.y)) ? box.y : 50;
                                box.vx = (typeof box.vx === 'number' && !isNaN(box.vx)) ? box.vx : (Math.random()-0.5)*BASE_SPEED_CONSTANT*0.5;
                                box.vy = (typeof box.vy === 'number' && !isNaN(box.vy)) ? box.vy : (Math.random()-0.5)*BASE_SPEED_CONSTANT*0.5;
                                box.element = null;
                            });
                            tv.nextBoxId = Math.max(tv.nextBoxId || 0, (tv.boxes.reduce((max, box) => Math.max(max, box.id ?? -1), -1) + 1));
                            tv.lastCornerHitTimestamp = (typeof tv.lastCornerHitTimestamp === 'number' && tv.lastCornerHitTimestamp > 0) ? tv.lastCornerHitTimestamp : null;
                            Object.keys(createDefaultTvState(0,0).upgrades).forEach(upgradeKey => {
                                if (!tv.upgrades || tv.upgrades[upgradeKey] === undefined) {
                                    console.warn(`TV ${tv.id} missing upgrade ${upgradeKey} from save, initializing to 0.`);
                                    if (!tv.upgrades) tv.upgrades = {};
                                    tv.upgrades[upgradeKey] = 0;
                                }
                            });
                        });
                        nextTvId = globalState.nextTvId;
                        boxCollisionTimers = {};
                        hitsThresholdCache = {}; // Clear cache on load

                        updateAllTvsPostMeta();
                        recalculateGlobalSynergy();

                        showNotification(`Loaded Game State${offlineGains > 0 ? ` (+${formatScore(offlineGains)} Offline Hits)` : ''}`);
                        needsInitialization = false;
                    } else {
                        console.warn("Invalid save data structure found or missing required keys, resetting.", loadedState);
                        localStorage.removeItem(SAVE_KEY);
                    }
                } catch (e) {
                    console.error("Load Error:", e);
                    showNotification("Load Error! Resetting.");
                    localStorage.removeItem(SAVE_KEY);
                }
            }

            if (needsInitialization) {
                console.log("No valid save found or load error, initializing new game.");
                globalState = createDefaultGlobalState();
                updateAllTvsPostMeta();
                recalculateGlobalSynergy();
                addTv();
                selectedBuyAmount = 1;
                hitsThresholdCache = {}; // Clear cache on init
            }

             recreateAllDomElements();
             checkMetaButtonVisibility();
             updateTotalHitsDisplay();
             updateAllTvGlows();
             requestAnimationFrame(handleGlobalResize);
        }

        // --- Utility: Deep Merge ---
        function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }
        function deepMerge(target, source) {
            if (!isObject(target) || !isObject(source)) return source;
            let output = { ...target };
            Object.keys(source).forEach(key => {
                const targetValue = target[key];
                const sourceValue = source[key];
                if (sourceValue === undefined || sourceValue === null) {
                    if (!(key in output) || key === 'lastCornerHitTimestamp') {
                        output[key] = sourceValue;
                    }
                    return;
                }
                if (isObject(sourceValue)) {
                    if (isObject(targetValue)) {
                       output[key] = deepMerge(targetValue, sourceValue);
                    } else {
                        output[key] = JSON.parse(JSON.stringify(sourceValue));
                    }
                } else if (Array.isArray(sourceValue)) {
                    output[key] = JSON.parse(JSON.stringify(sourceValue));
                } else {
                    output[key] = sourceValue;
                }
            });
             Object.keys(target).forEach(key => {
                if (!(key in source)) {
                    output[key] = target[key];
                }
            });
            return output;
        }


        // --- State Initialization ---
        function createDefaultTvState(index, id) {
            const tvState = {
                index: index, id: id,
                boxes: [], nextBoxId: 0,
                upgrades: {
                    hitValue: 0,
                    speed: 0,
                    cornerBonusFlat: 0,
                    cornerMultiplier: 0,
                    boxCollisionValue: 0
                },
                hitValue: 1,
                cornerHitBaseBonus: 2000, // Initial base value
                cornerHitMultiplier: 1.0,
                boxCollisionValue: 2,
                baseSpeedFactorMeta: 1.0,
                lastCornerHitTimestamp: null,
                screenWidth: 0, screenHeight: 0,
                dynamicBoxWidth: 0, dynamicBoxHeight: 0,
                elements: null,
                resizeRetryTimeout: null, adjustRetryTimeout: null,
            };
            recalculateDerivedTvState(tvState);
            return tvState;
        }
        function createDefaultGlobalState() {
            const now = Date.now();
            return {
                systemStaticCharges: 0,
                totalSessionHits: 0,
                lifetimeSessionHits: 0,
                tvStates: [],
                metaLevels: {
                    staticChargeGain: 0,
                    baseSpeed: 0,
                    baseMaxBoxes: 0,
                    tvSynergyBonus: 0,
                    cornersSuckBonus: 0,
                },
                synergyBonus: 1.0,
                maxBoxesPerTv: 2,
                hasRebootedOnce: false,
                nextTvId: 0,
                selectedBuyAmount: 1,
                lastSaveTimestamp: now,
            };
        }

        // --- Idle Progress Calculation ---
        function calculateIdleGains(idleTimeMs) {
            if (!globalState || !globalState.tvStates || idleTimeMs <= 0) return 0;

            let totalIdleHitsPerSec = 0;
            globalState.tvStates.forEach(tvState => {
                if (tvState.boxes.length === 0) return;

                const tvSpeedFactor = deriveTvSpeedFactor(tvState, tvState.upgrades.speed);
                const tvHitValue = tvState.hitValue;
                const numBoxes = tvState.boxes.length;

                const hitsPerSecPerBox = IDLE_HITS_PER_SEC_PER_BOX_BASE_FACTOR * tvSpeedFactor;
                const idleHitsPerTvPerSec = numBoxes * hitsPerSecPerBox * tvHitValue;
                totalIdleHitsPerSec += idleHitsPerTvPerSec;
            });

            const totalEffectiveIdleHitsPerSec = totalIdleHitsPerSec * globalState.synergyBonus * devSpeedFactor;
            const totalGainedHits = totalEffectiveIdleHitsPerSec * (idleTimeMs / 1000);

            return Math.max(0, Math.floor(totalGainedHits));
        }

        // --- Handle Visibility Change ---
        function handleVisibilityChange() {
            const now = performance.now();
            if (document.hidden) {
                timeHidden = now;
                saveGame();
            } else {
                if (timeHidden !== null) {
                    const idleTimeMs = now - timeHidden;
                    if (idleTimeMs > 1000) {
                         // Recalculate derived states *before* calculating offline gains
                         updateAllTvsPostMeta();
                         recalculateGlobalSynergy();
                         hitsThresholdCache = {}; // Clear cache after potential meta changes during offline

                        const gainedHits = calculateIdleGains(idleTimeMs);
                        if (gainedHits > 0) {
                            globalState.totalSessionHits += gainedHits;
                            globalState.lifetimeSessionHits += gainedHits;
                            showNotification(`Gained ${formatScore(gainedHits)} Hits while tab was inactive.`);
                            updateTotalHitsDisplay();
                            updateAllTvGlows();
                        }
                    }
                    timeHidden = null;
                }
                lastTimestamp = performance.now();
                 if (!gameLoopInterval && !document.hidden) {
                     gameLoopInterval = setInterval(() => gameLoop(performance.now()), TICK_RATE_MS);
                 }
                 requestAnimationFrame(handleGlobalResize);
                 globalState.tvStates.forEach((tv, index) => checkAndAdjustBoxPositions(index));
            }
        }

        // --- DEV Tools Functionality ---
        const devButton = document.getElementById('dev-button');
        const devPanel = document.getElementById('dev-panel');
        const devSimulateCornerButton = document.getElementById('dev-simulate-corner');
        const devHardResetButton = document.getElementById('dev-hard-reset');
        const devSpeedInput = document.getElementById('dev-speed-input');

        if (devButton && devPanel) {
            devButton.addEventListener('click', () => {
                devPanel.classList.toggle('hidden');
            });
        }

        if (devSimulateCornerButton) {
            devSimulateCornerButton.addEventListener('click', () => {
                if (!globalState || !globalState.tvStates || globalState.tvStates.length === 0) {
                    console.warn("DEV: No TVs available to simulate corner hit.");
                    showNotification("DEV: No TVs available!");
                    return;
                }
                const tvIndex = 0;
                const tvState = globalState.tvStates[tvIndex];
                if (!tvState || !tvState.elements || !tvState.elements.screen || !tvState.screenWidth) {
                    console.warn("DEV: First TV state or elements not ready.");
                     showNotification("DEV: TV not ready!");
                    return;
                }

                console.log(`DEV: Simulating corner hit on TV #${tvState.id}`);
                const finalCornerBonus = Math.ceil(tvState.cornerHitBaseBonus * tvState.cornerHitMultiplier * globalState.synergyBonus * devSpeedFactor);

                addTvHitScore(finalCornerBonus);
                updateTotalHitsDisplay();

                const cornerX = 0;
                const cornerY = 0;
                createSparkParticles(tvState, cornerX, cornerY);
                showFloatText(tvState, `CORNER HIT!\n+${formatScore(finalCornerBonus)}`, tvState.screenWidth / 2, tvState.screenHeight / 2, 'corner');
                showNotification(`DEV: Simulated Corner Hit (+${formatScore(finalCornerBonus)} Hits)`);

                updateTvGlow(tvIndex);
                updateAllTvGlows();
                if (upgradeModal.classList.contains('show')) {
                     hitsThresholdCache = {}; // Clear cache if hits changed
                     updateSelectedTvUpgradeButtons();
                     updateMetaUpgradeButtonsIfVisible();
                     updateRebootPreviewIfVisible();
                 }
            });
        }


        if (devSpeedInput) {
            devSpeedInput.value = devSpeedFactor;
            devSpeedInput.addEventListener('input', () => {
                let newSpeed = parseFloat(devSpeedInput.value);
                if (isNaN(newSpeed) || newSpeed <= 0) {
                    newSpeed = 0.1;
                    devSpeedInput.value = newSpeed;
                }

                if (devSpeedFactor !== newSpeed) {
                    devSpeedFactor = newSpeed;
                    console.log(`DEV: Score Factor set to ${devSpeedFactor}`);
                    // Optional: Update UI elements affected by score factor if modal is open
                    if (upgradeModal.classList.contains('show')) {
                        hitsThresholdCache = {}; // Clear cache if factor changes
                        updateMetaUpgradeButtonsIfVisible();
                        updateRebootPreviewIfVisible();
                    }
                }
            });
        }

        if (devHardResetButton) {
            devHardResetButton.addEventListener('click', () => {
                if (confirm('HARD RESET GAME?\n\nThis will erase ALL saved progress and reload the page.')) {
                    console.warn("DEV: Performing hard reset.");
                    localStorage.removeItem(SAVE_KEY);
                    showNotification("DEV: Hard Resetting...");
                    if(devPanel) devPanel.classList.add('hidden');
                    if(gameLoopInterval) clearInterval(gameLoopInterval); // Stop loop before reload
                    location.reload(true);
                }
            });
        }
        // --- End DEV Tools Functionality ---


        // --- Initialization ---
        async function init() {
             const startTime = performance.now();

             try {
                 console.log("Preloading images...");
                 await preloadImages([DVD_LOGO_URL, TV_BACKGROUND_URL]);
                 console.log("Images preloaded.");
             } catch (error) {
                 console.error("Image preloading issues:", error);
             }

             loadGame();

             // --- Event Listeners ---
             modalCloseButton.addEventListener('click', closeUpgradeModal);
             upgradeModal.addEventListener('click', (e) => { if (e.target === upgradeModal) closeUpgradeModal(); });
             metaMenuButton.addEventListener('click', () => openUpgradeModal(-1));
             window.addEventListener('resize', handleGlobalResize);
             document.addEventListener('visibilitychange', handleVisibilityChange);

             // --- Start Game Loop ---
             lastTimestamp = performance.now();
             lastSaveTime = Date.now();
             if (!document.hidden) {
                gameLoopInterval = setInterval(() => gameLoop(performance.now()), TICK_RATE_MS);
             }
             console.log("Initialization complete.");

             // --- Loading screen minimum time ---
             const endTime = performance.now();
             const elapsedTime = endTime - startTime;
             const delayTime = Math.max(0, MIN_LOADING_TIME_MS - elapsedTime);

             console.log(`Initialization took ${elapsedTime.toFixed(0)}ms. Delaying hide by ${delayTime.toFixed(0)}ms.`);

             setTimeout(() => {
                 if (loadingScreen) {
                     loadingScreen.classList.add('hidden');
                     setTimeout(() => {
                         if (loadingScreen && loadingScreen.parentNode) {
                              loadingScreen.parentNode.removeChild(loadingScreen);
                         }
                     }, 500);
                 }
             }, delayTime);
        }

        // --- Start ---
        if (document.readyState === 'loading') {
             document.addEventListener('DOMContentLoaded', init);
        } else {
             init();
        }

    })();
</script>

</body>
</html>
